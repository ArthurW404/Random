<html>
<head>
<title>Week 10 Lectures</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Week 10 Lectures</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Pipes</span></td><td align='right'><small>1/24</small></td></tr></table>
<p>
A common style of process interaction &nbsp;<small>(communication)</small>
<ul>
<li> producer process writes to byte stream &nbsp;<small>(cf. stdout)</small>
<li> consumer process reads from same byte stream
</ul>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe0-small.png]" src="Pics/processes/pipe0-small.png">
</div><p>
<br>
A <em>pipe</em> provides buffered i/o between producer and consumer
<ul>
<li> <small>producer blocks when buffer full; consumer blocks when buffer empty</small>
</ul>
Pipes are bidirectional unless processes close one file descriptor
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>2/24</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int pipe(int fd[2])</code></b></font></large>
<ul>
<li> open two file descriptors <small>(to be shared by processes)</small>
<li> <large><code>fd[0]</code></large> is opened for reading; <large><code>fd[1]</code></large> is opened for writing
<li> return 0 if OK, otherwise return -1 and sets <large><code>errno</code></large>
</ul>
<p><br>
Creating the pipe would then be followed by
<ul>
<li> <large><code>fork()</code></large> to create a child process
<li> both processes have copies of <large><code>fd[]</code></large>
<li> one can write to <large><code>fd[1]</code></large>, the other can read from <large><code>fd[0]</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>3/24</small></td></tr></table>
<p>
Creating a pipe ...
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe1-small.png]" src="Pics/processes/pipe1-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>4/24</small></td></tr></table>
<p>
Example: setting up a pipe
<p><pre><small>
int main(void)
{
   int fd[2], pid;  char buffer[10];
   assert(pipe(fd) == 0);
   pid = fork();
   assert(pid >= 0);
   if (pid != 0) {  <comment>// parent</comment>
      close(fd[0]); <comment>// writer; don't need fd[0]</comment>
      write(fd[1], "123456789", 10);
   }
   else {           <comment>// child</comment>
      close(fd[1]); <comment>// reader; don't need fd[1]</comment>
      read(fd[0], buffer, 10);
      printf("got \"%s\"\n", buffer);
   }
   return 0;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>5/24</small></td></tr></table>
<p>
A common pattern in pipe usage
<ul>
<li> set up a pipe between parent and child
<li> <large><code>exec()</code></large> child to become a new process talking to parent
</ul>
Because so common, a library function is available for it ...
<p><br>
<large><font color="#008800"><b><code>FILE *popen(char *<i>Cmd</i>, char *<i>Mode</i>)</code></b></font></large>
<ul>
<li> analogous to <large><code>fopen</code></large>, except first arg is a command
<li> <large><code><i>Cmd</i></code></large> is passed to shell for interpretation
<li> returns <large><code>FILE*</code></large> which be read/written depending on <large><code><i>Mode</i></code></large>
<li> returns <large><code>NULL</code></large> if can't establish pipe or invalid <large><code><i>Cmd</i></code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>6/24</small></td></tr></table>
<p>
Example of <large><code>popen()</code></large>
<p><pre>
int main(void)
{
   FILE *p = <font color='#000099'>popen("ls -l", "r")</font>;
   assert(p != NULL);
   char line[200], a[20],b[20],c[20],d[20];
   long int tot = 0, size;
   while (fgets(line,199,p) != NULL) {
      sscanf(line, "%s %s %s %s %ld",
                     a, b, c, d, &size);
      fputs(line, stdout);
      tot += size;
   }
   printf("Total: %ld\n", tot);
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Pipes: The Complete Story</span></td><td align='right'><small>7/24</small></td></tr></table>
<p>
A pipe talking from a parent to a child (as we had before) --
<p><pre><small>
int main(void)
{
   int p[2], pid;  char buffer[10];
   assert(pipe(p) == 0);
   pid = fork();
   assert(pid >= 0);
   if (pid != 0) {  <comment>// parent</comment>
      close(p[0]); <comment>// writer; don't need p[0]</comment>
      write(p[1], "123456789", 10);
   }
   else {           <comment>// child</comment>
      close(p[1]); <comment>// reader; don't need p[1]</comment>
      read(p[0], buffer, 10);
      printf("got \"%s\"\n", buffer);
   }
   return 0;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>8/24</small></td></tr></table>
<p>
-- only works because both processes share an address space
<ul>
<li> they can both access <large><code>p[]</code></large>
<li> they both have the same set of open file descriptors
</ul>
<br>
But what happens when we <large><code>execve()</code></large> in the child?
<ul>
<li> the transformed process has its own address space
<li> this address space does not contain <large><code>p[]</code></large>
</ul>
<br>
How can the transformed child access the pipe?
<p><br>
Clearly this is possible, because <large><code>popen()</code></large> does it ...
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>9/24</small></td></tr></table>
<p>
The two scenarios ...
<p><br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe-stuff-small.png]" src="Pics/processes/pipe-stuff-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>10/24</small></td></tr></table>
<p>
How to get a pipe to connect two different processes?
<ul>
<li> where the processes do not share an address space
</ul>
<br>
The trick: both processes have <em>stdin</em> (fd:0) and <em>stdout</em> (fd:1)
<ul>
<li> and fd's are retained even across an <large><code>exec</code></large>
</ul>
<br>
If we want parent to send data to an <large><code>exec</code></large>'d child
<ul>
<li> connect stdout and <large><code>p[1]</code></large> in the parent process
<li> connect stdin and <large><code>p[0]</code></large> in the child, then <large><code>exec</code></large>
</ul>
If we want an <large><code>exec</code></large>'d child to send data to parent
<ul>
<li> connect stdin and <large><code>p[0]</code></large> in the parent process
<li> connect stdout and <large><code>p[1]</code></large> in the child, then <large><code>exec</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>11/24</small></td></tr></table>
<p>
This connection is accomplished via the <large><code>dup2()</code></large> function
<ul>
<li> <large><font color="#008800"><b><code>dup2(fd1,fd2)</code></b></font></large> copies file descriptor <large><code>fd1</code></large> onto <large><code>fd2</code></large>
<li> recall that fd's are just indexes into a table of structures
<li> if <large><code>fd2</code></large> was already open, it is closed before the copy
</ul>
<br>
Note there is a related function <large><code>dup()</code></large>
<ul>
<li> <large><font color="#008800"><b><code>dup(fd1)</code></b></font></large> copies <large><code>fd1</code></large> onto "next free" fd
<li> "next free" = lowest numbered unused file descriptor
</ul>
<br>
Note: &nbsp; <large><code>dup2(fd1,0)</code></large> &nbsp;is like&nbsp; <large><code>close(0);</code></large> <large><code>dup(fd1);</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>12/24</small></td></tr></table>
<p>
Pipe between two exec'd processes (step 1):
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe-step1-small.png]" src="Pics/processes/pipe-step1-small.png">
</div><p>
<br>
<tiny>Adapted from University of Illinois CS241</tiny>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>13/24</small></td></tr></table>
<p>
Pipe between two exec'd processes (step 2):
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe-step2-small.png]" src="Pics/processes/pipe-step2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>14/24</small></td></tr></table>
<p>
Pipe between two exec'd processes (step 3):
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe-step3-small.png]" src="Pics/processes/pipe-step3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>15/24</small></td></tr></table>
<p>
Pipe between two exec'd processes (step 4):
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe-step4-small.png]" src="Pics/processes/pipe-step4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes: The Complete Story</span></td><td align='right'><small>16/24</small></td></tr></table>
<p>
Pipe between two exec'd processes (step 5):
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe-step5-small.png]" src="Pics/processes/pipe-step5-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Pipes</span></td><td align='right'><small>17/24</small></td></tr></table>
<p>
Use pipes to implement IPC between ...
<ol>
<li> a parent process (P) and a child process (C)  &nbsp; <small>(P &rarr; C)</small>
<p>
<li> a parent process (P) and a child process (C)  &nbsp; <small>(P &harr; C)</small>
<p>
<li> a parent process (P) and an exec'd process (E)  &nbsp; <small>(P &rarr; E)</small>
<p>
<li> a parent process (P) and an exec'd process (E)  &nbsp; <small>(P &larr; C)</small>
<p>
<li> exec'd process (E1) and another exec'd process (E2)  &nbsp; <small>(E1 &rarr; E2)</small>
</ol>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Message Queues</span></td><td align='right'><small>18/24</small></td></tr></table>
<p>
Pipes operate between at most two processes on same host
<ul>
<li> processes come initially from parent/child pair <small>(<large><code>fork</code></large>)</small>
<li> connection established via <i>shared file descriptors</i>
</ul>
A <em>message queue</em> (MQ) provides a mechanism
<ul>
<li> for unrelated processes to pass information 
<li> along a buffered channel shared by many processes
</ul>
Processes connect to message queues by name
<ul>
<li> MQ names look like &nbsp;"<large><code>/</code></large><i>SomeCharacters</i> " &nbsp;<small>(no slash chars)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>19/24</small></td></tr></table>
<p>
Message queue architecture
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/msg-queue0-small.png]" src="Pics/processes/msg-queue0-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>20/24</small></td></tr></table>
<p>
Requires <large><font color="#008800"><b><code>#include &lt;mqueue.h&gt;</code></b></font></large>, &nbsp; giving &nbsp;<large><font color="#008800"><b><code>mqd_t</code></b></font></large>
<p>
<large><font color="#008800"><b><code>mqd_t mq_open(char *<i>Name</i>, int <i>Flags</i>)</code></b></font></large>
<ul>
<li> create a new message queue, or open existing one
<li> <large><code>Flags</code></large> are like those for <large><code>fopen()</code></large> (e.g. <large><code>O_RDONLY</code></large>)
</ul>
<p>
<large><font color="#008800"><b><code>int mq_close(mqd_t *<i>MQ</i>)</code></b></font></large>
<ul>
<li> finish accessing message queue <large><code><i>MQ</i></code></large>
<li> the message queue continues to exist &nbsp;<small>(cf. <large><code>fclose()</code></large>)</small>
</ul>
<br>
More details <large><code>man 7 mq_overview</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>21/24</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mq_send(mqd_t <i>MQ</i>, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *<i>Msg</i>, int <i>Size</i>, uint <i>Prio</i>)</code></b></font></large>
<ul>
<li> adds message <large><code><i>Msg</i></code></large> to message queue <large><code><i>MQ</i></code></large>
<li> <large><code><i>Prio</i></code></large> gives priority
	&nbsp;<small>(determines order of messages on MQ)</small>
<li> if <large><code><i>MQ</i></code></large> is full ...
<ul>
<li> blocks until MQ space available
<li> if <large><code>O_NONBLOCK</code></large> is set, fails and returns error
</ul>
<li> also, <large><font color="#008800"><b><code>mq_timedsend()</code></b></font></large> which
<ul>
<li> waits for specified time if MQ full
<li> fails if still no space on MQ after timeout
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>22/24</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mq_receive(mqd_t <i>MQ</i>,<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *<i>Msg</i>, int <i>Size</i>, uint *<i>Prio</i>)</code></b></font></large>
<ul>
<li> removes highest priority message from queue <large><code><i>MQ</i></code></large>
<li> if <large><code><i>*Prio</i></code></large> is not NULL, receives message priority
<li> if <large><code><i>MQ</i></code></large> is empty ...
<ul>
<li> blocks until a message is added to <large><code><i>MQ</i></code></large>
<li> if <large><code>O_NONBLOCK</code></large> is set, fails and returns error
</ul>
<li> if several processes blocked on <large><code>mq_receive()</code></large>
<ul>
<li> oldest and highest priority process receives the message
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>23/24</small></td></tr></table>
<p>
Pseudo-code showing structure of a MQ server program:
<p><pre><small>
main() {
   <comment>// set up message queue</comment>
   attr = (0,#msgs,MsgSize)
   mode = O_CREAT|O_RDWR
   mq = <font color='#000099'>mq_open</font>("/queue", mode, Perms, &attr)
   while (1) {
      <comment>// ask for request ... wait</comment>
      <font color='#000099'>mq_receive</font>(mq, InBuf, Size, NULL)
      <comment>... determine response ... put in OutBuf ...</comment>
      <font color='#000099'>mq_send</font>(mq, OutBuf, strlen(OutBuf), 0)
   }
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>24/24</small></td></tr></table>
<p>
Pseudo-code showing structure of a MQ client program:
<p><pre><small>
main() {
   <comment>// set up message queue</comment>
   attr = (0,#msgs,MsgSize)
   mode = O_RDWR
   mq = <font color='#000099'>mq_open</font>("/queue", mode, Perms, &attr)
   <comment>// read request from user</comment>
   while (fgets(Request, Size, stdin) {
      <font color='#000099'>mq_send</font>(mq, Request, strlen(OutBuf), 0)
      <font color='#000099'>mq_receive</font>(mq, InBuf, Size, NULL)
      <comment>... get response ... act accordingly ...</comment>
   }
}
</small></pre><p>
<p><hr><p>
<small><small>Produced: 8 Aug 2019</small></small>
</body>
</html>

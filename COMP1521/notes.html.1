<html>
<head>
<title>Week 02</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Week 02</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Bitwise Operations in C</span></td><td align='right'><small>1/57</small></td></tr></table>
<p>
Reminder:
<ul>
<li> everything is ultimately a string of bits
<li> e.g. <large><code>unsigned char</code></large> = 8-bit value
<li> e.g. literal bit-string <large><code>0b01110001</code></large>
<li> e.g. literal hexademical <large><code>0x71</code></large>
<li> <large><code>&amp;</code></large> = bitwise AND
	&nbsp; <small>( 0 <large><code>&amp;</code></large> x = 0, &nbsp; 1 <large><code>&amp;</code></large> x = x )</small>
<li> <large><code>|</code></large> = bitwise OR 
	&nbsp; <small>( 0 <large><code>|</code></large> x = x, &nbsp; 1 <large><code>|</code></large> x = 1 )</small>
<li> <large><code>~</code></large> = bitwise NEG 
	&nbsp; <small>( <large><code>~</code></large>0 = 1, &nbsp; <large><code>~</code></large>1 = 0 )</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Bitwise XOR</span></td><td align='right'><small>2/57</small></td></tr></table>
<p>
The <large><code>^</code></large> operator
<ul>
<li> takes two values (1,2,4,8 bytes), treats as sequence of bits
<li> performs logical XOR on each corresponding pair of bits
<li> result contains same number of bits as inputs
</ul>
Example:
<p><pre>
  00100111           XOR | 0  1
^ 11100011           ----|-----
  --------             0 | 0  1
  11000100             1 | 1  0
</pre><p>
Used in e.g. generating random numbers, building adder circuits
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Left Shift</span></td><td align='right'><small>3/57</small></td></tr></table>
<p>
The <large><code>&lt;&lt;</code></large> operator
<ul>
<li> takes a single value (1,2,4,8 bytes), treats as sequence of bits
<li> and a small positive integer <i>x</i>
<li> moves (shifts) each bit <i>x</i> positions to the left
<li> left-end bit vanishes; right-end bit replaced by zero
<li> result contains same number of bits as input
</ul>
Example:
<p><pre>
  00100111 &lt;&lt; 2      00100111 &lt;&lt; 8
  --------           --------
  10011100           00000000
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Right Shift</span></td><td align='right'><small>4/57</small></td></tr></table>
<p>
The <large><code>&gt;></code></large> operator
<ul>
<li> takes a single value (1,2,4,8 bytes), treats as sequence of bits
<li> and a small positive integer <i>x</i>
<li> moves (shifts) each bit <i>x</i> positions to the right
<li> right-end bit vanishes; left-end bit replaced by zero**
<li> result contains same number of bits as input
</ul>
Example:
<p><pre>
  00100111 >&gt; 2      00100111 >&gt; 8
  --------           --------
  00001001           00000000
</pre><p>
** if <large><code>signed</code></large> quantity, sign bit replaces left-end bit
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Bitwise Operations</span></td><td align='right'><small>5/57</small></td></tr></table>
<p>
Given the following variable declarations:
<p><pre>
    <comment>// a signed 8-bit value</comment>
signed char x = 0b01010101;
    <comment>// an 8-bit value</comment>
unsigned char y = 0b11001100;
</pre><p>
What is the value of each of the following expressions:
<ul>
<li> <large><code>(x & y)</code></large> &nbsp;&nbsp;&nbsp; <large><code>(x ^ y)</code></large>
<li> <large><code>(x &lt;< 1)</code></large> &nbsp;&nbsp; <large><code>(y &lt;< 1)</code></large>
<li> <large><code>(x >&gt; 1)</code></large> &nbsp;&nbsp; <large><code>(y >&gt; 1)</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Makefiles</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Multi-module C Programs and Makefiles</span></td><td align='right'><small>7/57</small></td></tr></table>
<p>
All large systems written in C ...
<ul>
<li> are built as a large number of <large><code>.c</code></large> files
<li> which are compiled separately
<li> and then combined to form an executable
</ul>
Small (tiny) example:
<p><pre>
$ gcc -c Stack.c          <comment># produces Stack.o</comment>
$ gcc -c bm.c             <comment># produces bm.o</comment>
$ gcc -o bm bm.o Stack.o  <comment># links Stack.o + bm.o</comment>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Multi-module C Programs and Makefiles</span></td><td align='right'><small>8/57</small></td></tr></table>
<p>
While developing a large system ...
<ul>
<li> edit one <large><code>.c</code></large> file at a time &nbsp; (e.g. <large><code>vi x.c</code></large>)
<li> recompile just that <large><code>.c</code></large> file &nbsp; (e.g. <large><code>gcc -c x.c</code></large>)
<li> then combine all <large><code>.o</code></large> files again &nbsp; (e.g. <large><code>gcc *.o</code></large>)
</ul>
If you edit several <large><code>.c</code></large> files ...
<ul>
<li> need to keep track of which ones you changed
<li> compile all the modified files <small>(and just those?)</small>
<li> then combine all <large><code>.o</code></large> files again
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Multi-module C Programs and Makefiles</span></td><td align='right'><small>9/57</small></td></tr></table>
<p>
Within a large software system ...
<ul>
<li> <em>dependencies</em> exist between files, e.g.
<ul>
<li> <large><code>x.o</code></large> depends on <large><code>x.c</code></large> and <large><code>y.h</code></large>
</ul>
<li> <em>actions</em> state how to produce <i>targets</i> from <i>sources</i>, e.g.
<ul>
<li> can create <large><code>x.o</code></large> from <large><code>x.c</code></large> and <large><code>y.h</code></large> using <large><code>gcc</code></large>
</ul>
<li> <em>rules</em> combine dependencies and actions
<ul>
<li> if <large><code>x.c</code></large> or <large><code>y.h</code></large> changes, rebuild <large><code>x.o</code></large> with <large><code>gcc</code></large>
</ul>
</ul>
A &nbsp;<large><font color="#008800"><b><code>Makefile</code></b></font></large>&nbsp; contains definitions and rules
<p>
The &nbsp;<large><font color="#008800"><b><code>make</code></b></font></large>&nbsp; command uses a <large><code>Makefile</code></large> to rebuild a system
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Multi-module C Programs and Makefiles</span></td><td align='right'><small>10/57</small></td></tr></table>
<p>
Example <font color='#CC0000'>dependencies</font> and <font color='#009900'>actions</font>
<br><br>
<p><div class='center'>
<img alt="[Diagram:Pics/compile/dependencies-small.png]" src="Pics/compile/dependencies-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Multi-module C Programs and Makefiles</span></td><td align='right'><small>11/57</small></td></tr></table>
<p>
Example &nbsp;<large><code>Makefile</code></large> <small>(i)</small>
<p><pre>
<font color='#CC0000'>bm</font> : <font color='#0000CC'>bm.o Stack.o</font>
	<font color='#009900'>gcc -o bm bm.o Stack.o</font>

<font color='#CC0000'>bm.o</font> : <font color='#0000CC'>bm.c Stack.h</font>
	<font color='#009900'>gcc -c -Wall -Werror bm.c</font>

<font color='#CC0000'>Stack.o</font> : <font color='#0000CC'>Stack.c Stack.h</font>
	<font color='#009900'>gcc -c -Wall -Werror Stack.c</font>
</pre><p>
<br>
Legend: &nbsp;<font color='#CC0000'>target</font>, &nbsp;<font color='#0000CC'>source</font>, &nbsp;<font color='#009900'>action</font>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Multi-module C Programs and Makefiles</span></td><td align='right'><small>12/57</small></td></tr></table>
<p>
Example &nbsp;<large><code>Makefile</code></large> <small>(ii)</small>
<p><pre>
CC = gcc
CFLAGS = -Wall -Werror

bm : bm.o Stack.o
    gcc -o bm bm.o Stack.o

bm.o : bm.c Stack.h

Stack.o : Stack.c Stack.h
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Memory</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>The C View of Data</span></td><td align='right'><small>14/57</small></td></tr></table>
<p>
A C program sees data as a collection of <em>variables</em>
<p><pre>
<font color='#0000CC'>int</font> <font color='#CC0000'>g</font> = 2;

int main(void)
{
    <font color='#0000CC'>int</font>   <font color='#CC0000'>i</font>;
    <font color='#0000CC'>int</font>   <font color='#CC0000'>v</font>[5]
    <font color='#0000CC'>char *</font><font color='#CC0000'>s</font> = "Hello";
    <font color='#0000CC'>int  *</font><font color='#CC0000'>n</font> = malloc(sizeof(int));
    ...
}
</pre><p>
<br>
Each variable has properties e.g. &nbsp;<font color='#CC0000'>name</font>, &nbsp;<font color='#0000CC'>type</font>, ...
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>15/57</small></td></tr></table>
<p>
Variables are examples of <em>computational objects</em>
<p>
Each computational object has
<ul>
<li> a <em>location</em> in memory <small>(obtainable via <large><code>&</code></large>)</small>
<li> a <em>value</em> &nbsp; <small>(ultimately just a bit-string)</small>
<li> a <em>name</em> &nbsp; <small>(unless created by <large><code>malloc()</code></large>)</small>
<li> a <em>type</em>, which determines ...
<ul>
<li> its <em>size</em> &nbsp; <small>(in units of whole bytes, <large><code>sizeof</code></large>)</small>
<li> how to <em>interpret</em> its value; what <em>operations</em> apply
</ul>
<li> a <em>scope</em> &nbsp; <small>(where it's visible within the program)</small>
<li> a <em>lifetime</em> &nbsp; <small>(during which part of program execution it exists)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>16/57</small></td></tr></table>
<p>
Memory regions during C program execution ...
<br><br>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/regions-small.png]" src="Pics/memory/regions-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>17/57</small></td></tr></table>
<p>
Example of runtime stack during call to <large><code>h()</code></large>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/stack-frames-small.png]" src="Pics/memory/stack-frames-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 2: Properties of Variables</span></td><td align='right'><small>18/57</small></td></tr></table>
<p>
Identify the properties of each of the named objects in the following:
<p><pre>
int <font color='#CC0000'>a</font>;          <comment>// global int variable</comment>

int main(void) {
   int  <font color='#CC0000'>b</font>;      <comment>// local int variable</comment>
   char <font color='#CC0000'>c</font>;      <comment>// local char variable</comment>
   char <font color='#CC0000'>d</font>[10];  <comment>// local char array</comment>
   ...
}

int <font color='#CC0000'>e</font>;          <comment>// global? int variable</comment>

int <font color='#CC0000'>f</font>(int <font color='#CC0000'>g</font>) {  <comment>// function + parameter</comment>
   double <font color='#CC0000'>h</font>;    <comment>// local double variable</comment>
   ...
} 
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>The Physical View of Data</span></td><td align='right'><small>19/57</small></td></tr></table>
<p>
Memory = indexed array of bytes
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/byte-array-small.png]" src="Pics/memory/byte-array-small.png">
</div><p>
<p>
Indexes are "memory addresses" (a.k.a. pointers)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory</span></td><td align='right'><small>20/57</small></td></tr></table>
<p>
Properties of physical memory
<ul>
<li> called main memory &nbsp; <small>(or RAM, or primary storage, ...)</small>
<li> indexes are "memory addresses" (a.k.a. pointers)
<li> data can be fetched in chunks of 1,2,4,8 bytes
<li> cost of fetching any byte is same (ns)
<li> can be volatile or non-volatile
</ul>
When addressing objects in memory ...
<ul>
<li> any byte address can be used to fetch 1-byte object
<li> byte address for <i>N</i>-byte object must be divisible by <i>N</i>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory</span></td><td align='right'><small>21/57</small></td></tr></table>
<p>
Memories can be categorised as <em>big-endian</em> or <em>little-endian</em>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/endian-small.png]" src="Pics/memory/endian-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Data Representation</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Data Representation</span></td><td align='right'><small>23/57</small></td></tr></table>
<p>
Ultimately, memory allows you to
<ul>
<li> load bit-strings of sizes 1,2,4,8 bytes
<li> from <i>N</i>-byte boundary addresses
<li> into registers in the CPU
</ul>
What you are presented with is a string of 8,16,32,64 bits
<p>
Need to <em>interpret</em> this bit-string as a meaningful value
<p>
<em>Data representations</em> provide a way of assigning meaning to bit-strings
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Character Data</span></td><td align='right'><small>24/57</small></td></tr></table>
<p>
Character data has several possible representations (encodings)
<p>
The two most common:
<ul>
<li> ASCII (ISO 646)
<ul>
<li> 7-bit values, using lower 7-bits of a byte <small>(top bit always zero)</small>
<li> can encode roman alphabet, digits, punctuation, control chars
</ul>
<li> UTF-8 (Unicode) 
<ul>
<li> 8-bit values, with ability to extend to multi-byte values
<li> can encode all human languages plus other symbols
<p>
(e.g. &nbsp;<big>&Sqrt; &nbsp; &Sum; &nbsp;  &forall; &nbsp; &Exists; </big> &nbsp; or <img src="Pics/misc/emoji-small.png"> )
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>ASCII Character Encoding</span></td><td align='right'><small>25/57</small></td></tr></table>
<p>
Uses values in the range <large><code>0x00</code></large> to <large><code>0x7F</code></large> (0..127)
<p>
Characters partitioned into sequential groups
<ul>
<li> control characters (0..31) ... e.g. <large><code>'\0'</code></large>, <large><code>'\n'</code></large>
<li> punctuation chars (32..47,91..96,123..126)
<li> digits (48..57) ... <large><code>'0'</code></large>..<large><code>'9'</code></large>
<li> upper case alphabetic (65..90) ... <large><code>'A'</code></large>..<large><code>'Z'</code></large>
<li> lower case alphabetic (97..122) ... <large><code>'a'</code></large>..<large><code>'z'</code></large>
</ul>
In C, can map between char and ascii code by e.g. <large><code>((int)'a')</code></large>
<p>
Sequential nature of groups allow for e.g. <large><code>(ch - '0')</code></large>
<p>
See &nbsp; <large><code>man 7 ascii</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unicode</span></td><td align='right'><small>26/57</small></td></tr></table>
<p>
Widely-used standard for expressing "writing systems"
<ul>
<li> not all writing systems use a small set of discrete symbols
</ul>
Basically, a 32-bit representation of a wide range of symbols
<ul>
<li> around 140K symbols, covering 140 different languages
</ul>
Using 32-bits for <i>every</i> symbol would be too expensive
<ul>
<li> e.g. standard roman alphabet + punctuation needs only 7-bits
</ul>
<small>
More compact character encodings have been developed (e.g. UTF-8)
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>UTF-8 Character Encoding</span></td><td align='right'><small>27/57</small></td></tr></table>
<p>
UTF-8 uses a variable-length encoding as follows
<p>
<div class='center'>
<table border="1" cellpadding="5" cellspacing="0">
<tr>
 <td><b>#bytes</b></td>
 <td><b>#bits</b></td>
 <td><b>Byte 1</b></td>
 <td><b>Byte 2</b></td>
 <td><b>Byte 3</b></td>
 <td><b>Byte 4</b></td>
</tr>
<tr>
 <td>1</td><td>7</td><td><large><code>0xxxxxxx</code></large></td><td>-</td><td>-</td><td>-</td>
</tr>
<tr>
 <td>2</td><td>11</td><td><large><code>110xxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td>-</td><td>-</td>
</tr>
<tr>
 <td>3</td><td>16</td><td><large><code>1110xxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td>-</td>
</tr>
<tr>
 <td>4</td><td>21</td><td><large><code>11110xxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td>
</tr>
</table>
</div>
<p>
The 127 1-byte codes are compatible with ASCII
<p>
The 2048 2-byte codes include most Latin-script alphabets
<p>
The 65536 3-byte codes include most Asian languages
<p>
The 2097152 4-byte codes include symbols and emojis and ...
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... UTF-8 Character Encoding</span></td><td align='right'><small>28/57</small></td></tr></table>
<p>
UTF-8 examples
<p>
<div class='center'>
<table border="1" cellpadding="5" cellspacing="0">
<tr>
 <td><b>ch</b></td>
 <td><b>unicode</b></td>
 <td><b>bits</b></td>
 <td><b>simple binary</b></td>
 <td><b>UTF-8 binary</b></td>
</tr>
<tr>
 <td>$</td>
 <td>U+0024</td>
 <td>7</td>
 <td><tt><font color='#CC0000'>010 0100</font></tt></td>
 <td><tt>0<font color='#CC0000'>0100100</font></tt></td>
</tr>
<tr>
 <td>&cent;</td>
 <td>U+00A2</td>
 <td>11</td>
 <td><tt><font color='#009900'>000 10</green<font color='#CC0000'>10 0010</font></tt></td>
 <td><tt>110<font color='#009900'>00010</font> 10<font color='#CC0000'>100010</font></tt></td>
</tr>
<tr>
 <td>&#x20AC;</td>
 <td>U+20AC</td>
 <td>16</td>
 <td><tt><font color='#0000CC'>0010</font> <font color='#009900'>0000 10</font><font color='#CC0000'>10 1100</font></tt></td>
 <td><tt>1110<font color='#0000CC'>0010</font> 10<font color='#009900'>000010</font> 10<font color='#CC0000'>101100</font></tt></td>
</tr>
<tr>
 <td><big>&#x10348;</big></td>
 <td>U+10348</td>
 <td>21</td>
 <td><tt><font color='#996600'>0 00</font><font color='#0000CC'>01 0000</font> <font color='#009900'>0011 01</font><font color='#CC0000'>00 1000</font></tt></td>
 <td><tt>11110<font color='#996600'>000</font> 10<font color='#0000CC'>010000</font> 10<font color='#009900'>001101</font> 10<font color='#CC0000'>001000</font></tt></td>
</tr>
</table>
</div>
<p>
Unicode strings can be manipulated in C (e.g. "<img src="Pics/misc/annyong-small.png">")
<p>
Like other C strings, they are terminated by a 0 byte (i.e. <large><code>'\0'</code></large>)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 3: UTF-8 Unicode Encoding</span></td><td align='right'><small>29/57</small></td></tr></table>
<p>
For each of the following symbols, with their Unicode value
<ul>
<li> show the bit-string that would be used to represent them
</ul>
Symbols:
<ul>
<li> <big>&amp;</big> &nbsp;&nbsp; <large><code>U+00026</code></large>
<li> <big>&micro;</big> &nbsp;&nbsp; <large><code>U+000B5</code></large>
<li> <big>&check;</big> &nbsp;&nbsp; <large><code>U+02713</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Numeric Data</span></td><td align='right'><small>30/57</small></td></tr></table>
<p>
Numeric data comes in two major forms
<ul>
<li> integer ... subset (range) of the mathematical integers
<li> floating point ... subset of the mathematical real numbers
</ul>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/numbers-small.png]" src="Pics/memory/numbers-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Integer Constants</span></td><td align='right'><small>31/57</small></td></tr></table>
<p>
Three ways to write integer constants in C
<ul>
<li> <large><code>42</code></large> ... signed decimal &nbsp;(<large><code>0</code></large>..<large><code>9</code></large>)
<li> <large><code><font color='#CC0000'>0x</font>2A</code></large> ... unsigned hexadecimal &nbsp;(<large><code>0</code></large>..<large><code>F</code></large>)
<li> <large><code><font color='#CC0000'>0</font>52</code></large> ... signed octal &nbsp;(<large><code>0</code></large> ..<large><code>7</code></large>)
</ul>
Variations
<ul>
<li> <large><code>123U</code></large> ... <large><code>unsigned int</code></large> value &nbsp; <small>(typically 32 bits)</small>
<li> <large><code>123L</code></large> ... <large><code>long int</code></large> value &nbsp; <small>(typically 64 bits)</small>
<li> <large><code>123S</code></large> ... <large><code>short int</code></large> value &nbsp; <small>(typically 16 bits)</small>
</ul>
Invalid constants lie outside the range for their type, e.g.
<ul>
<li> <large><code>4294967296</code></large>, &nbsp; <large><code>-1U</code></large>, &nbsp; <large><code>666666S</code></large>, &nbsp; <large><code>078</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unsigned integers</span></td><td align='right'><small>32/57</small></td></tr></table>
<p>
The <large><font color="#008800"><b><code>unsigned int</code></b></font></large> data type
<ul>
<li> commonly 32 bits, storing values in the range 0 .. 2<sup>32</sup>-1
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/unsigned-int-small.png]" src="Pics/memory/unsigned-int-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unsigned integers</span></td><td align='right'><small>33/57</small></td></tr></table>
<p>
Value interpreted as binary number
<p>
E.g. consider an 8-bit unsigned int
<p>
<large><code>01001101</code></large> &nbsp;=&nbsp; 2<sup>6</sup> + 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>0</sup> &nbsp;=&nbsp; 64 + 8 + 4 + 1 &nbsp;=&nbsp; 77
<p>
Addition is bitwise with carry
<p><pre>
  00000001     00000001     01001101     11111111
+ 00000010   + 00000011   + 00001011   + 00000001
  --------     --------     --------     --------
  00000011     00000100     01011000     00000000
</pre><p>
Most machines will also flag the <em>overflow</em> in the fourth example
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 4: Hexadecimal &harr; Binary &harr; Decimal</span></td><td align='right'><small>34/57</small></td></tr></table>
<p>
When working at the machine level
<ul>
<li> as we will be with MIPS assembler
<li> useful to know how to map between Hex/Decimal/Binary
</ul>
Convert these 8-bit binary numbers to hexadecimal:
<ul>
<li> <large><code>00001001</code></large>, &nbsp;<large><code>00001101</code></large>, &nbsp;<large><code>00101010</code></large>, &nbsp;<large><code>00110011</code></large>, &nbsp;<large><code>11001100</code></large>
</ul>
Convert these 8-bit binary numbers to decimal:
<ul>
<li> <large><code>00001001</code></large>, &nbsp;<large><code>00001101</code></large>, &nbsp;<large><code>00101010</code></large>, &nbsp;<large><code>00110011</code></large>, &nbsp;<large><code>11001100</code></large>
</ul>
Convert the following decimal numbers to 8-bit binary:
<ul>
<li> 15, &nbsp;64, &nbsp;99, &nbsp;200, &nbsp;256
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Signed integers</span></td><td align='right'><small>35/57</small></td></tr></table>
<p>
The <large><font color="#008800"><b><code>int</code></b></font></large> data type
<ul>
<li> commonly 32 bits, storing values in the range -2<sup>31</sup> .. 2<sup>31</sup>-1
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/signed-int-small.png]" src="Pics/memory/signed-int-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>36/57</small></td></tr></table>
<p>
Several possible representations for negative values
<ul>
<li> signed magnitude ... first bit is sign, rest are magnitude
<li> ones complement ... form <i>-N</i> by inverting all bits in <i>N</i>
<li> twos complement ... form <i>-N</i> by inverting <i>N</i> and adding 1
</ul>
In all representations, +ve numbers have 0 in leftmost bit
<p>
Examples: representations of (8-bit) -5  (where 5 is <large><code>00000101</code></large>)
<ul>
<li> <large><code><font color='#CC0000'>1</font>0000101</code></large> ... signed magnitude
<li> <large><code>11111010</code></large> ... ones complement
<li> <large><code>11111011</code></large> ... twos complement
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>37/57</small></td></tr></table>
<p>
<em>Signed magnitude</em>: Easy to form <i>-X</i> from <i>X</i> ... OR in high-order bit
<p>
A problem (using 8-bit <large><code>int</code></large>s) ...
<ul>
<li> what do these numbers represent? &nbsp;<large><code>00000000</code></large>, &nbsp;<large><code>10000000</code></large>
</ul>
Two zeroes ... one positive, one negative
<p>
Another problem: &nbsp;<i>x + -x &ne; 0</i> (mostly) with simple addition
<p><pre>
  00000011  3     00101010  42      01111111  127
+ 10000011 -3   + 10101010 -42    + 11111111 -127
  --------        --------          --------
  10000110 !0     11010100  !0      01111110   !0
</pre><p>
To fix requires extra hardware in ALU
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>38/57</small></td></tr></table>
<p>
<em>Ones complement</em>: Easy to form <i>-X</i> from <i>X</i> ... NEG all bits
<p>
A problem (using 8-bit <large><code>int</code></large>s) ...
<ul>
<li> what do these numbers represent? &nbsp;<large><code>00000000</code></large>, &nbsp;<large><code>11111111</code></large>
</ul>
Two zeroes ... one positive, one negative
<p>
At least &nbsp;<i>x + -x</i> is equal to one of the zeroes with simple addition
<p><pre>
  00000011  3     00101010  42      01111111
+ 11111100 -3   + 11010101 -42    + 10000000
  --------        --------          --------
  11111111 -0     11111111  -0      11111111 -0
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>39/57</small></td></tr></table>
<p>
<em>Twos complement</em>: to form <i>-X</i> from <i>X</i> ... NEG all bits, then add 1
<p>
Now have only one representation for zero (<large><code>00000000</code></large>)
<ul>
<li> <large><code>-0</code></large> &nbsp;=&nbsp; <large><code>~00000000+1</code></large> &nbsp;=&nbsp; <large><code>11111111+1</code></large> &nbsp;=&nbsp; <large><code>00000000</code></large>
</ul>
Only one zero value. &nbsp; Also, <i>-(-x)</i> = <i>x</i>
<p>
Even better, &nbsp;<i>x + -x = 0</i> in all cases with simple addition
<p><pre>
  00000011  3     00101010  42      01111111
+ 11111101 -3   + 11010110 -42    + 10000001
  --------        --------          --------
  00000000  0     00000000   0      00000000  0
</pre><p>
Always produces an "overflow" bit, but can ignore this
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 5: Binary&harr;decimal Conversion</span></td><td align='right'><small>40/57</small></td></tr></table>
<p>
Convert these decimal numbers to 8-bit 2's complement binary:
<ul>
<li> 15, &nbsp;64, &nbsp;127, &nbsp;128
</ul>
<br>
What decimal numbers do these 8-bit 2's complement represent:
<ul>
<li> <large><code>11111111</code></large>, &nbsp;<large><code>11010110</code></large>, &nbsp;<large><code>10111101</code></large>
</ul>
<br>
Demonstrate the addition of <i>x + -x</i>, where <i>x</i> is
<ul>
<li> 5, &nbsp;20, &nbsp;64, &nbsp;99, &nbsp;127
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Pointers</span></td><td align='right'><small>41/57</small></td></tr></table>
<p>
Pointers represent memory addresses/locations
<ul>
<li> number of bits depends on memory size, but typically 32-bits
<li> data pointers reference addresses in <em>data</em>/<em>heap</em>/<em>stack</em> regions
<li> function pointers reference addresses in <em>code</em> region
</ul>
Many kinds of pointers, one for each data type, but
<ul>
<li> <large><code>sizeof(int *)</code></large> &nbsp;=&nbsp; <large><code>sizeof(char *)</code></large> <br>
	=&nbsp; <large><code>sizeof(double *)</code></large> &nbsp;=&nbsp; <large><code>sizeof(struct X *)</code></large>
</ul>
Pointer <em>values</em> must be appropriate for data type, e.g.
<ul>
<li> <large><code>(char *)</code></large> ... can reference any byte address
<li> <large><code>(int *)</code></large> ... must have &nbsp;<i>addr</i> <large><code>%4 == 0</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 6: Valid Pointers</span></td><td align='right'><small>42/57</small></td></tr></table>
<p>
Which of the following are likely to be valid pointers
<p><pre>
0x00000000   0x00001000   0x00001001
0x7f000000   0x7f000001   0x7f000004
</pre><p>
to objects of the following types
<p><div class='center'>
<img alt="[Diagram:Pics/clang/memory-regions-small.png]" src="Pics/clang/memory-regions-small.png">
</div><p>
<p>
Before this, try: &nbsp; <em>www.zeetings.com/cs1521</em>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pointers</span></td><td align='right'><small>43/57</small></td></tr></table>
<p>
Can "move" from object to object by <em>pointer arithmetic</em>
<p>
For any pointer <i>T</i><large><code> *p;</code></large>, &nbsp;&nbsp;<large><code>p++</code></large> increases <large><code>p</code></large> by <large><code>sizeof(</code></large><i>T</i> <large><code>)</code></large>
<p>
Examples (assuming 16-bit pointers):
<p><pre>
char   *p = 0x6060;  p++;  assert(p == 0x6061)
int    *q = 0x6060;  q++;  assert(q == 0x6064)
double *r = 0x6060;  r++;  assert(r == 0x6068)
</pre><p>
A common (efficient) paradigm for scanning a string
<p><pre>
char *s = "a string";
char *c;
<comment>// print a string, char-by-char</comment>
for (c = s; *c != '\0'; c++) {
   printf("%c", *c);
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 7: Sum an array of <large><code>int</code></large>s</span></td><td align='right'><small>44/57</small></td></tr></table>
<p>
Write a function
<p><pre>
int sumOf(int *a, int n)  { ... }
</pre><p>
to sum the elements of array <large><code>a[]</code></large> containing <large><code>n</code></large> values.
<p>
Implement it two ways:
<ul>
<li> using the "standard" approach with an index
<li> using a pointer that scans the elements
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Floating Point Numbers</span></td><td align='right'><small>45/57</small></td></tr></table>
<p>
Floating point numbers model a (tiny) subset of <big>&reals;</big>
<ul>
<li> many real values don't have exact representation &nbsp;<small>(e.g. 1/3)</small>
<li> numbers close to zero have higher precision (more accurate)
</ul>
C has two floating point types
<ul>
<li> <large><font color="#008800"><b><code>float</code></b></font></large> ... typically 32-bit quantity  <small>(lower precision, narrower range)</small>
<li> <large><font color="#008800"><b><code>double</code></b></font></large> ... typically 64-bit quantity <small>(higher precision, wider range)</small>
</ul>
Literal floating point values: &nbsp;<large><code>3.14159</code></large>, &nbsp;<large><code>1.0/3</code></large>, &nbsp;<large><code>1.0e-9</code></large>
<p><pre>
printf("%10.4lf", (double)2.718281828459);
<comment>displays &bbrk;&bbrk;&bbrk;&bbrk;2.7183</comment>
printf("%20.20lf", (double)4.0/7);
<comment>displays 0.57142857142857139685</comment>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>46/57</small></td></tr></table>
<p>
IEEE 754 standard ...
<ul>
<li> scientific notation with <em>fraction</em> <i>F</i> and <em>exponent</em> <i>E</i>
<li> numbers have form <i>F &times; 2<sup>E</sup></i>, where both <i>F</i> and <i>E</i> can be -ve
<li> <large><code>INFINITY</code></large> = representation for <big>&infin;</big> and <big>-&infin;</big> (e.g. 1.0/0)
<li> <large><code>NAN</code></large> = representation for invalid value (e.g. sqrt(-1.0))
</ul>
Fraction part is <em>normalised</em> &nbsp;<small>(i.e. 1.2345&times;10<sup>2</sup> rather than 123.45)</small>
<p>
In binary, exponent is represented relative to a bias value <i>B</i>
<ul>
<li> if the unsigned exponent value is <i>e</i>, the actual value is <i>e-B</i>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>47/57</small></td></tr></table>
<p>
Example of normalising the fraction part in binary:
<ul>
<li> <large><code>1010.1011</code></large> &nbsp;is normalized as&nbsp; <large><code>1.0101011&times;2<sup>011</sup></code></large>
<li> <large><code>1010.<font color='#009900'>1011</font></code></large> = 10 + <font color='#009900'>11</font>/16 = 10.6875
<li> <large><code>1.<font color='#009900'>0101011</font>&times;2<sup>011</sup></code></large> = (1 + <font color='#009900'>43</font>/128) * 2<sup>3</sup> = 1.3359375 * 8 = 10.6875
</ul>
The normalised fraction part always has <large><code>1</code></large> before the decimal point.
<p>
Example of determining the exponent in binary:
<ul>
<li> assume an 8-bit exponent, then bias <i>B</i> = 2<sup>8-1</sup>-1 = 127
<li> valid bit patterns for exponent &nbsp;<large><code>00000001</code></large> .. <large><code>11111110</code></large>
<li> exponent values &nbsp; -126 .. 127
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>48/57</small></td></tr></table>
<p>
Internal structure of floating point values
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/float-rep-small.png]" src="Pics/memory/float-rep-small.png">
</div><p>
<p>
More complex representation than <large><code>int</code></large> because <i>1.dddd e dd</i>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>49/57</small></td></tr></table>
<p>
Example <small>(single-precision)</small>:
<p><pre>
150.75 = 10010110.11
         <comment>// normalise fraction, compute exponent</comment>
       = <font color='#996600'>1</font>.<font color='#0000CC'>001011011</font> &times; 2<sup><font color='#009900'>7</font></sup>
         <comment>// determine sign bit,</comment>
         <comment>// map fraction to 24 bits,</comment>
         <comment>// map exponent relative to baseline</comment>
       = <font color='#CC0000'>0</font><font color='#009900'>100000110</font><font color='#0000CC'>001011011</font>000000000000000
</pre><p>
where <font color='#CC0000'>red</font> is sign bit, <font color='#009900'>green</font> is exponent, <font color='#0000CC'>blue</font> is fraction
<p>
Note: <i>B</i>=127, <i>e</i>=2<sup>7</sup>, so exponent = 127+7 = 134 = <large><code>10000110</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 8: Floating point &rarr; Decimal</span></td><td align='right'><small>50/57</small></td></tr></table>
<p>
Convert the following floating point numbers to decimal.
<p>
Assume that they are in IEEE 754 single-precision format.
<p><pre>
0 10000000 11000000000000000000000

1 01111110 10000000000000000000000
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Arrays</span></td><td align='right'><small>51/57</small></td></tr></table>
<p>
Arrays are defined to have <i>N</i> elements, each of type <i>T</i>
<p>
Examples:
<p><pre>
int    a[100];    <comment>// array of 10 ints</comment>
char   str[256];  <comment>// array of 256 chars</comment>
double vec[100];  <comment>// array of 100 doubles</comment>
</pre><p>
Elements are laid out adjacent in memory
<p><div class='center'>
<img alt="[Diagram:Pics/memory/array-in-mem-small.png]" src="Pics/memory/array-in-mem-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Arrays</span></td><td align='right'><small>52/57</small></td></tr></table>
<p>
Assuming an array declaration like &nbsp;<i>Type</i><large><code> v[</code></large><i>N </i><large><code>]</code></large> ...
<ul>
<li> individual array elements are accessed via indices 0..<i>N-1</i>
<li> total amount of space allocated to array <i>N</i> &times; <large><code>sizeof(</code></large><i>Type </i><large><code>)</code></large>
<li> array name gives address of first element &nbsp;(e.g. <large><code>v</code></large> = <large><code>&v[0]</code></large>)
<li> array indexing can be treated as &nbsp;<large><code>v[i]</code></large> &cong; <large><code>*(v+i)</code></large>
</ul>
Strings are just arrays of <large><code>char</code></large> with a <large><code>'\0'</code></large> terminator
<ul>
<li> constant strings have <large><code>'\0'</code></large> added automatically
<li> string buffers must allow for element to hold <large><code>'\0'</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Arrays</span></td><td align='right'><small>53/57</small></td></tr></table>
<p>
When arrays are "passed" to a function, actually pass <large><code>&a[0]</code></large>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/string-param-small.png]" src="Pics/memory/string-param-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Arrays</span></td><td align='right'><small>54/57</small></td></tr></table>
<p>
Arrays can be created automatically or via <large><code>malloc()</code></large>
<p><pre>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
    char str1[7] = "oh boy";
    char *str2;  // no array object yet

    str2 = malloc(20*sizeof(char));
    strcpy(str2, str1);
    printf("str1 is located at %p and contains %s\n", &str1, str1);
    printf("str2 is located at %p and contains %p where %s is located\n", &str2, str2, str2);
    
</pre><p>
Two separate arrays (different &amp;'s), but have same contents
<p>
<small>(except for the unitialised parts of the arrays)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Structs</span></td><td align='right'><small>55/57</small></td></tr></table>
<p>
Structs are defined to have a number of components
<ul>
<li> each component has a <i>Name</i>&nbsp; and a <i>Type</i>
</ul>
Example:
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-student-small.png]" src="Pics/memory/struct-student-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs</span></td><td align='right'><small>56/57</small></td></tr></table>
<p>
Internal layout of <large><code>struct</code></large> components determined by compiler
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-student2-small.png]" src="Pics/memory/struct-student2-small.png">
</div><p>
<p>
Each name maps to a byte offset within the <large><code>struct</code></large>
<p>
<small>E.g. in first example <large><code>id</code></large> = offset 0, <large><code>given</code></large> = offset 4, <large><code>family</code></large> = offset 54, etc.</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs</span></td><td align='right'><small>57/57</small></td></tr></table>
<p>
To ensure <em>alignment</em>, internal "padding" may be needed
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-pad-small.png]" src="Pics/memory/struct-pad-small.png">
</div><p>
<p>
Padding wastes space; re-order fields to minimise waste.
<p><hr><p>
<small><small>Produced: 8 Aug 2019</small></small>
</body>
</html>

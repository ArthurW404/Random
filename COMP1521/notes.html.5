<html>
<head>
<title>Week 06</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Week 06</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>File Systems</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File Systems</span></td><td align='right'><small>2/37</small></td></tr></table>
<p>
<em>File systems</em> provide a mechanism for managing <em>stored data</em>:
<ul>
<li> typically on a disk device <small>(or, nowadays, on SSD)</small>
<li> allocating chunks of space on the device to <em>files</em>
<ul>
<li> where a file is viewed as a sequence of bytes
</ul>
<li> allowing access to files by <em>name</em> and with <em>access rights</em>
<li> arranging access to files via <em>directories</em> (folders)
<li> maintaining information about files/directories (<em>meta-data</em>)
<li> dealing with damage on the storage device ("bad blocks")
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unix/Linux File System</span></td><td align='right'><small>3/37</small></td></tr></table>
<p>
Unix/Linux file system is tree-structured
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/unix-fs-small.png]" src="Pics/opsys/unix-fs-small.png">
</div><p>
<small>(We say it's "tree structured", but symlinks actually make it into a graph)</small>
<p>
Processes have a notion of their location within the file system
<ul>
<li> <em>current working directory</em> &nbsp; (CWD)
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux File System</span></td><td align='right'><small>4/37</small></td></tr></table>
<p>
The file system is used to access various types of objects:
<ul>
<li> files, directories (folders), devices, processes, sockets, ...
</ul>
Objects are referenced via a <em>path</em>  &nbsp;<small>(...<large><code>/x/y/z/</code></large>...)</small>
<p>
Paths can be
<ul>
<li> <em>absolute</em> &nbsp;<small>(full path from root)</small>
<p>
e.g. <large><code><font color='#CC0000'>/</font>usr/include/stdio.h</code></large>, &nbsp;<large><code><font color='#CC0000'>/</font>home/jas/cs1521/</code></large>
<li> <em>relative</em> &nbsp;<small>(path starts from CWD)</small>
<p>
e.g. <large><code>../../another/path/prog.c</code></large>, &nbsp;<large><code>./a.out</code></large>, &nbsp;<large><code>a.out</code></large>
</ul>
<br>
Q: Why do we have to run <large><code>a.out</code></large> as <large><code>./a.out</code></large>?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Reminder: File Systems</span></td><td align='right'><small>5/37</small></td></tr></table>
<p>
<em>File systems</em> manage stored data <small>(e.g. on disk, SSD)</small>
<p>
<em>File</em> = named sequence of bytes, stored on device
<ul>
<li> file system maps name to location on device
<li> file system maintains meta-data (e.g. access rights)
</ul>
<em>Directory</em> = file containing references to other files
<p>
System calls provide low-level API to manipulate files &nbsp;<small>(byte streams)</small>
<p>
Libraries provide higher-level API to manipulate files &nbsp;<small>(text streams)</small>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/filesys/streams-small.png]" src="Pics/filesys/streams-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File Operations (stdio.h)</span></td><td align='right'><small>6/37</small></td></tr></table>
<p>
Standard I/O functions provide a layer above system calls ...
<ul>
<li> <large><font color="#008800"><b><code>FILE *</code></b></font></large> ... handle on an open file <small>(and a buffer)</small>
<li> <large><font color="#008800"><b><code>FILE *fopen(</code></b></font></large><i>Name</i><large><font color="#008800"><b><code>, </code></b></font></large><i>Mode</i><large><font color="#008800"><b><code>)</code></b></font></large>
	&nbsp; <small>(<i>Mode</i> &nbsp;e.g. <large><code>"r"</code></large>, <large><code>"w"</code></large>, <large><code>"a"</code></large>)</small>
<li> <large><font color="#008800"><b><code>int fclose(FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>)</code></b></font></large>
	&nbsp; <small>(<i>Stream</i> from <large><code>fopen()</code></large>)</small>
<li> <large><font color="#008800"><b><code>char *fgets(char *</code></b></font></large><i>Buffer</i><large><font color="#008800"><b><code>, int</code></b></font></large> <i>Size</i><large><font color="#008800"><b><code>, FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>)</code></b></font></large>
<li> <large><font color="#008800"><b><code>char *fputs(char *</code></b></font></large><i>Buffer</i><large><font color="#008800"><b><code>, FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>)</code></b></font></large>
</ul>
E.g.
<p><pre><small>
FILE *in;  char buf[100];  char *fileName ="...";
if ((in = fopen(fileName,"r")) == NULL)
   error(errno, errno, "Can't open %s", fileName);
while (fgets(buf, 100, in) != NULL)
   fputs(buf, stdout);
fclose(in);
</small></pre><p>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File Operations (stdio.h)</span></td><td align='right'><small>7/37</small></td></tr></table>
<p>
Other functions ...
<ul>
<li> <large><font color="#008800"><b><code>int fscanf(FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>, char *</code></b></font></large><i>Format</i><large><font color="#008800"><b><code>,</code></b></font></large> ...<large><font color="#008800"><b><code>)</code></b></font></large>
<li> <large><font color="#008800"><b><code>int fprintf(FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>, char *</code></b></font></large><i>Format</i><large><font color="#008800"><b><code>,</code></b></font></large> ...<large><font color="#008800"><b><code>)</code></b></font></large>
<li> <large><font color="#008800"><b><code>int fgetc(FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>)</code></b></font></large>
<li> <large><font color="#008800"><b><code>int fputc(int </code></b></font></large>Character</i><large><font color="#008800"><b><code>, FILE *</code></b></font></large><i>Stream</i><large><font color="#008800"><b><code>)</code></b></font></large>
</ul>
Also, specialised versions of I/O functions, e.g.
<ul>
<li> <large><font color="#008800"><b><code>scanf(</code></b></font></large>...<large><font color="#008800"><b><code>)</code></b></font></large> == <large><font color="#008800"><b><code>fscanf(stdin, </code></b></font></large>...<large><font color="#008800"><b><code>)</code></b></font></large>
<li> <large><font color="#008800"><b><code>printf(</code></b></font></large>...<large><font color="#008800"><b><code>)</code></b></font></large> == <large><font color="#008800"><b><code>fprintf(stdout, </code></b></font></large>...<large><font color="#008800"><b><code>)</code></b></font></large>
<li> <large><font color="#008800"><b><code>getchar()</code></b></font></large> == <large><font color="#008800"><b><code>fgetc(stdin)</code></b></font></large>
<li> <large><font color="#008800"><b><code>putchar(</code></b></font></large><i>ch</i><large><font color="#008800"><b><code>)</code></b></font></large> == <large><font color="#008800"><b><code>fputc(</code></b></font></large><i>ch</i><large><font color="#008800"><b><code>,stdin)</code></b></font></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Opening/Closing Files</span></td><td align='right'><small>8/37</small></td></tr></table>
<p>
If <large><code>abc</code></large> is an existing file
<ul>
<li> why is &nbsp;<large><code>fopen("abc","w")</code></large>&nbsp; potentially bad?
<li> why is &nbsp;<large><code>fopen("abc","a")</code></large>&nbsp; potentially better?
</ul>
<br>
What will be the output from ...
<p><pre>
FILE *in;  int ch;
while (1) {
   if ((in = fopen("abc", "r")) == NULL)
      break;
   while ((ch = fgetc(in)) != EOF)
      putc(ch, stdout);
}
</pre><p>
Question: https://www.zeetings.com/cs1521
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unix File System</span></td><td align='right'><small>9/37</small></td></tr></table>
<p>
Unix defines a range of file-system-related types:
<ul>
<li> <large><font color="#008800"><b><code>off_t</code></b></font></large> ... offsets within files
<ul>
<li> typically, <large><code>long</code></large> and signed to allow backward refs
</ul>
<li> <large><font color="#008800"><b><code>size_t</code></b></font></large> ... number of bytes in some object
<ul>
<li> unsigned, since objects can't have negative size
</ul>
<li> <large><font color="#008800"><b><code>ssize_t</code></b></font></large> ... sizes of read/written blocks
<ul>
<li> like <large><code>size_t</code></large>, but signed to allow for error values
</ul>
<li> <large><font color="#008800"><b><code>struct stat</code></b></font></large> ... file system object metadata
<ul>
<li> stores information <i>about</i> file, not file content
<li> requires <large><code>ino_t</code></large>, <large><code>dev_t</code></large>, <large><code>time_t</code></large>, <large><code>uid_t</code></large>, ...
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix File System</span></td><td align='right'><small>10/37</small></td></tr></table>
<p>
Metadata for file system objects is stored in <em>inodes</em>, which hold
<ul>
<li> physical location on storage device of file data
<li> file type <small>(regular file, directory, ...)</small>, file size <small>(bytes/blocks)</small>
<li> ownership, access permissions, timestamps <small>(create/access/update)</small>
</ul>
Each file system <em>volume</em> has a table of inodes in a known location
<p>
Note: an inode does not contain the name of the file
<p>
Access to a file by name requires a <em>directory</em>
<ul>
<li> where a directory is effectively a list of (name,inode) pairs
</ul>
<br>
<small>
Note: very small files can potentially be stored in an inode (inlining)
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix File System</span></td><td align='right'><small>11/37</small></td></tr></table>
<p>
Access to files by name proceeds as ...
<ul>
<li> open directory and scan for <i>name</i>
<li> if not found, "No such file or directory"
<li> if found as (<i>name</i>,<large><code>ino</code></large>), access inode table <large><code>inodes[ino]</code></large>
<li> collect file metadata and ...
<ul>
<li> check file access permissions given current user/group
<ul>
<li> if don't have required access, "Permission denied"
</ul>
<li> collect information about file's location and size
<li> update access timestamp
</ul>
<li> use physical location to access device and manipulate file data
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File System Operations</span></td><td align='right'><small>12/37</small></td></tr></table>
<p>
Unix presents a uniform interface to file system objects
<ul>
<li> functions/syscalls manipulate objects as a <em>stream of bytes</em>
<li> accessed via a <em>file descriptor</em> <small>(index into a system table)</small>
</ul>
Some common operations:
<ul>
<li> <large><code>open()</code></large> ... open a file system object, returning a file descriptor
<li> <large><code>close()</code></large> ... stop using a file descriptor
<li> <large><code>read()</code></large> ... read some bytes into a buffer from a file descriptor
<li> <large><code>write()</code></large> ... write some bytes from a buffer to a file descriptor
<li> <large><code>lseek()</code></large> ... move to a specified offset within a file
<li> <large><code>stat()</code></large> ... get meta-data about a file system object
<li> <large><code>mount()</code></large> ... place a filesystem onto the system file tree
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>13/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int open(char *</code></b></font></large><i>Path</i><large><font color="#008800"><b><code>, int</code></b></font></large> <i>Flags</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> attempt to open an object at <i>Path</i>, according to <i>Flags</i>
<li> flags (defined in <large><code>&lt;fcntl.h&gt;</code></large>)
<ul>
<li> <large><code>O_RDONLY</code></large> ... open object for reading
<li> <large><code>O_WRONLY</code></large> ... open object for writing
<li> <large><code>O_APPEND</code></large> ... append on each write
<li> <large><code>O_RDWR</code></large> ... open object for reading and writing
<li> <large><code>O_CREAT</code></large> ... create object if doesn't exist
<li> <large><code>O_TRUNC</code></large> ... truncate to size 0
</ul>
<li> flags can be combined e.g. <large><code>(O_WRONLY|O_CREAT)</code></large>
<li> if successful, return file descriptor <small>(small +ve <large><code>int</code></large>)</small>
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 2: <large><code>open()</code></large> vs <large><code>fopen()</code></large></span></td><td align='right'><small>14/37</small></td></tr></table>
<p>
What combinations of <large><code>open()</code></large> flags best capture <br>
the meaning of the following <large><code>fopen()</code></large> modes:
<ul>
<li> &nbsp; <large><code>"r"</code></large>
<li> &nbsp; <large><code>"w</code></large>
<li> &nbsp; <large><code>"a"</code></large>
<li> &nbsp; <large><code>"r+"</code></large>
<li> &nbsp; <large><code>"w+"</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>15/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int close(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> attempt to release an open file descriptor
<li> if this is the last reference to object, release its resources
<li> if successful, return 0
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
</ul>
Could be unsuccessful if <i>FileDesc</i> is not an open file descriptor
<p>
<small>
An aside: removing an object e.g. via <large><code>rm</code></large>
<ul>
<li> removes the object's entry from a directory
<li> but the inode and data persist until
<ul>
<li> all processes accessing the object <large><code>close()</code></large> their handle
<li> all references to the inode from other directories are removed
</ul>
<li> after this, the inode and the blocks on storage device are recycled
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>16/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>ssize_t read(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>, void *</code></b></font></large><i>Buffer</i><large><font color="#008800"><b><code>, size_t</code></b></font></large> <i>Count</i><large><font color="#008800"><b><code>)</code></b></font></large>
<p>
<ul>
<li> attempt to read <i>Count</i> bytes from <i>FileDesc</i> into <i>Buffer</i>
<li> if "successful", return number of bytes actually read (<i>NRead</i>)
<li> if currently positioned at end of file, return 0
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
<li> does not check whether <i>Buffer</i> contains enough space
<li> advances the file offset by <i>NRead</i>
<li> does not treat <large><code>'\n'</code></large> as special, nor is there <large><code>EOF</code></large>
</ul>
<p>
<br>
<small>
Once a file is <large><code>open()</code></large>'d ...
<ul>
<li> the "current position" in the file is maintained as part of the fd entry
<li> the "current position" is modified by <large><code>read()</code></large>, <large><code>write()</code></large> and <large><code>lseek()</code></large>
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>17/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>ssize_t write(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>, void *</code></b></font></large><i>Buffer</i><large><font color="#008800"><b><code>, size_t</code></b></font></large> <i>Count</i><large><font color="#008800"><b><code>)</code></b></font></large>
<p>
<ul>
<li> attempt to write <i>Count</i> bytes from <i>Buffer</i> onto <i>FileDesc</i>
<li> if "successful", return number of bytes actually written (<i>NWritten</i>)
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
<li> does not check whether <i>Buffer</i> has <i>Count</i> bytes of data
<li> advances the file offset by <i>NWritten</i> bytes
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/write-small.png]" src="Pics/opsys/write-small.png">
</div><p>
Question: https://www.zeetings.com/cs1521
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 3: (FILE *) vs FileDesc</span></td><td align='right'><small>18/37</small></td></tr></table>
<p>
Write three programs to scan a file and write it to stdout
<ul>
<li> for one use <large><code>stdio.h</code></large> and read char-by-char
<li> for one use <large><code>stdio.h</code></large> and read line-by-line
<li> for one use <large><code>unistd.h</code></large> and read block-by-block
</ul>
Notes:
<ul>
<li> stdout is accessible via file descriptor 1
<li> check whether the size of <large><code>read()</code></large>'s buffer matters
<li> system calls are relatively expensive operations
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>19/37</small></td></tr></table>
<p>
Functions from <large><code>stdio.h</code></large> tend to be <large><code>char</code></large>-oriented
<p>
File-descriptor-based system calls deal with byte sequences
<ul>
<li> bytes can be interpreted as <large><code>char</code></large>, <large><code>int</code></large>, <large><code>struct</code></large>, etc
<li> so, many kinds of objects can be <large><code>read()</code></large> or <large><code>write()</code></large> <font color='#CC0000'>**</font>
</ul>
Allows programmers to manipulate files of data items, e.g.
<ul>
<li> list of <large><code>double</code></large> values read from sensor device
<li> collection of <large><code>Student</code></large> records
</ul>
<p><br>
<small>
<font color='#CC0000'>**</font> you cannot save/restore pointer values using <large><code>write()</code></large>/<large><code>read()</code></large>
<ul>
<li> because they refer to memory addresses within a process instance
<li> and a different process instance might already have used those addresses
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>20/37</small></td></tr></table>
<p>
Files of <i>records</i> can be produced by
<ul>
<li> either, <large><code>write()</code></large>ing chunks of bytes from <large><code>struct</code></large> objects
<li> or, printing formatted text representation of <large><code>struct</code></large> data
</ul>
The latter approach is a form of <em>serialisation</em>
<p>
For the <large><code>write()</code></large> approach:
<ul>
<li> no need to worry about formatting issues
<li> writes entire structure, even if string buffers half empty
<li> can <large><code>lseek()</code></large> to <i>i<sup>th</i> struct via <i>i*sizeof(StructType)</i>
</ul>
For the printing approach:
<ul>
<li> produces files that are human-readable
<li> only uses as many bytes as required from string buffers
<li> can access structures only sequentially <small>(unless using padding)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>21/37</small></td></tr></table>
<p>
Example of <large><code>write()</code></large>ing records vs <large><code>printf()</code></large>ing records
<p><pre>
typedef struct _student {
    int id; char name[99]; float wam;
} Student;
int infd, outfd; <comment>// file descriptors</comment>
FILE *inf, *outf; <comment>// file pointers</comment>

Student stu;  <comment>... set values in stu.id, etc ...</comment>

<font color='#009900'>write</font>(outfd, &stu, sizeof(struct _student));
  <comment>vs</comment>
<font color='#009900'>fprintf</font>(outf, "%d:%s:%f\n",
             stu.id, stu.name, stu.wam);

<font color='#009900'>read</font>(infd, &stu, sizeof(Student));
  <comment>vs</comment>
<font color='#009900'>fscanf</font>(inf, "%d:[^:]:%f\n", <comment>// maybe?</comment>
            &(stu.id), &(stu.name), &(stu.wam));
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 4: File of Structs</span></td><td align='right'><small>22/37</small></td></tr></table>
<p>
Write a program to ...
<ul>
<li> read in data about one student
<li> append the data to a file of students
</ul>
Write a program to ...
<ul>
<li> scan the file of students and print data for each one
</ul>
Write two versions of each program ...
<ul>
<li> one using the <large><code>write()</code></large>/<large><code>read()</code></large> approach
<li> one using the <large><code>printf()</code></large>/<large><code>scanf()</code></large> approach
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>23/37</small></td></tr></table>
<p>
Functions from <large><code>stdio.h</code></large> tend to be <large><code>char</code></large>-oriented
<p>
File-descriptor-based system calls deal with byte sequences
<ul>
<li> bytes can be interpreted as <large><code>char</code></large>, <large><code>int</code></large>, <large><code>struct</code></large>, etc
<li> so, many kinds of objects can be <large><code>read()</code></large> or <large><code>write()</code></large> <font color='#CC0000'>**</font>
</ul>
Allows programmers to manipulate files of data items, e.g.
<ul>
<li> list of <large><code>double</code></large> values read from sensor device
<li> collection of <large><code>Student</code></large> records
</ul>
<p><br>
<small>
<font color='#CC0000'>**</font> you cannot save/restore pointer values using <large><code>write()</code></large>/<large><code>read()</code></large>
<ul>
<li> because they refer to memory addresses within a process instance
<li> and a different process instance might already have used those addresses
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>24/37</small></td></tr></table>
<p>
Files of <i>records</i> can be produced by
<ul>
<li> either, <large><code>write()</code></large>ing chunks of bytes from <large><code>struct</code></large> objects
<li> or, printing formatted text representation of <large><code>struct</code></large> data
</ul>
The latter approach is a form of <em>serialisation</em>
<p>
For the <large><code>write()</code></large> approach:
<ul>
<li> no need to worry about formatting issues
<li> writes entire structure, even if string buffers half empty
<li> can <large><code>lseek()</code></large> to <i>i<sup>th</i> struct via <i>i*sizeof(StructType)</i>
</ul>
For the printing approach:
<ul>
<li> produces files that are human-readable
<li> only uses as many bytes as required from string buffers
<li> can access structures only sequentially <small>(unless using padding)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>25/37</small></td></tr></table>
<p>
Example of <large><code>write()</code></large>ing records vs <large><code>printf()</code></large>ing records
<p><pre>
typedef struct _student {
    int id; char name[99]; float wam;
} Student;
int infd, outfd; <comment>// file descriptors</comment>
FILE *inf, *outf; <comment>// file pointers</comment>

Student stu;  <comment>... set values in stu.id, etc ...</comment>

<font color='#009900'>write</font>(outfd, &stu, sizeof(struct _student));
  <comment>vs</comment>
<font color='#009900'>fprintf</font>(outf, "%d:%s:%f\n",
             stu.id, stu.name, stu.wam);

<font color='#009900'>read</font>(infd, &stu, sizeof(Student));
  <comment>vs</comment>
<font color='#009900'>fscanf</font>(inf, "%d:[^:]:%f\n", <comment>// maybe?</comment>
            &(stu.id), &(stu.name), &(stu.wam));
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 5: Files of Structs</span></td><td align='right'><small>26/37</small></td></tr></table>
<p>
Consider a new <large><code>Student</code></large> struct ...
<p><pre><small>
typedef struct _student {
  int id; char given[50]; char family[50]; int prog; float wam;
} Student;
</small></pre><p>
Write a program to ...
<ul>
<li> read in data about one student
<li> append the data to a file of students
</ul>
Write a program to ...
<ul>
<li> scan the file of students and print data for each one
</ul>
Write two versions of each program ...
<ul>
<li> one using the <large><code>write()</code></large>/<large><code>read()</code></large> approach
<li> one using the <large><code>printf()</code></large>/<large><code>scanf()</code></large> approach
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>27/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>off_t lseek(int</code></b></font></large> <i>FileDesc</i><large><font color="#008800"><b><code>, off_t</code></b></font></large> <i>Offset</i><large><font color="#008800"><b><code>, int</code></b></font></large> <i>Whence</i><large><font color="#008800"><b><code>)</code></b></font></large>
<p>
<ul>
<li> set the "current position" of the <i>FileDesc</i>
<li> <i>Offset</i> is in units of bytes, and can be negative
<li> <i>Whence</i> can be one of ...
<ul>
<li> <large><code>SEEK_SET</code></large> ... set file position to <i>Offset</i> from start of file
<li> <large><code>SEEK_CUR</code></large> ... set file position to <i>Offset</i> from current position
<li> <large><code>SEEK_END</code></large> ... set file position to <i>Offset</i> from end of file
</ul>
<li> seeking beyond end of file leaves a gap which reads as 0's
<li> seeking back beyond start of file sets position to start of file
</ul>
<br>
Example: &nbsp;<large><code>lseek(fd, 0, SEEK_END);</code></large>  &nbsp;&nbsp; <small>(move to end of file)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 6: Seeking to a Record</span></td><td align='right'><small>28/37</small></td></tr></table>
<p>
Create a new program that shows one particular <large><code>Student</code></large> record
<ul>
<li> the parameter is the index of the record to be displayed
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/filesys/student-file-small.png]" src="Pics/filesys/student-file-small.png">
</div><p>
Write one program using <large><code>stdio</code></large> and another using <large><code>unistd</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 7: Updating a Record</span></td><td align='right'><small>29/37</small></td></tr></table>
<p>
Write a program that updates one particular <large><code>Student</code></large> record
<ul>
<li> the parameter is the index of the record to be updated
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/filesys/student-file2-small.png]" src="Pics/filesys/student-file2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>30/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int stat(char *</code></b></font></large><i>FileName</i><large><font color="#008800"><b><code>, struct stat *</code></b></font></large><i>StatBuf</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> stores meta-data associated with <i>FileName</i> into <i>StatBuf</i>
<li> information includes
<ul>
<li> inode number, file type + access mode, owner, group
<li> size in bytes, storage block size, allocated blocks
<li> time of last access/modification/status-change
</ul>
<li> returns -1 and sets <large><code>errno</code></large> if meta-data not accessible
</ul>
<large><font color="#008800"><b><code>int fstat(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>, struct stat *</code></b></font></large><i>StatBuf</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> same as <large><code>stat()</code></large> but gets data via an open file descriptor
</ul>
<large><font color="#008800"><b><code>int lstat(char *</code></b></font></large><i>FileName</i><large><font color="#008800"><b><code>, struct stat *</code></b></font></large><i>StatBuf</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> same as <large><code>stat()</code></large> but doesn't follow symbolic links
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>31/37</small></td></tr></table>
<p>
File system <em>links</em> allow multiple paths to access the same data
<p>
Hard links
<ul>
<li> multiple directory entries referencing the same inode
<li> the two entries must be on the same filesystem
</ul>
Symbolic links (symlinks)
<ul>
<li> a file containing the path name of another file
<li> opening the symlink opens the file being referenced
</ul>
Example:
<p><pre>
-rw-r----- 2 cs1521 46 Sep 10 22:28 fileA
-rw-r----- 2 cs1521 46 Sep 10 22:28 fileB
lrwxrwxrwx 1 cs1521  5 Sep 10 22:29 fileC -> fileA
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>32/37</small></td></tr></table>
<p>
File <large><code>stat</code></large> structure:
<p><pre>
struct stat {
   dev_t     st_dev;     <comment>// ID of device containing file</comment>
   ino_t     st_ino;     <comment>// inode number</comment>
   mode_t    st_mode;    <comment>// file type + permissions</comment>
   nlink_t   st_nlink;   <comment>// number of hard links</comment>
   uid_t     st_uid;     <comment>// user ID of owner</comment>
   gid_t     st_gid;     <comment>// group ID of owner</comment>
   dev_t     st_rdev;    <comment>// device ID (if special file)</comment>
   off_t     st_size;    <comment>// total size, in bytes</comment>
   blksize_t st_blksize; <comment>// blocksize for file system I/O</comment>
   blkcnt_t  st_blocks;  <comment>// number of 512B blocks allocated</comment>
   time_t    st_atime;   <comment>// time of last access</comment>
   time_t    st_mtime;   <comment>// time of last modification</comment>
   time_t    st_ctime;   <comment>// time of last status change</comment>
};
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>33/37</small></td></tr></table>
<p>
The <large><code>st_mode</code></large> is a bit-string containing some of:
<p><pre><small>
S_IFLNK    0120000   symbolic link
S_IFREG    0100000   regular file
S_IFBLK    0060000   block device
S_IFDIR    0040000   directory
S_IFCHR    0020000   character device
S_IFIFO    0010000   FIFO

S_IRUSR    0000400   owner has read permission
S_IWUSR    0000200   owner has write permission
S_IXUSR    0000100   owner has execute permission

S_IRGRP    0000040   group has read permission
S_IWGRP    0000020   group has write permission
S_IXGRP    0000010   group has execute permission

S_IROTH    0000004   others have read permission
S_IWOTH    0000002   others have write permission
S_IXOTH    0000001   others have execute permission
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>34/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mkdir(char *</code></b></font></large><i>PathName</i><large><font color="#008800"><b><code>, mode_t</code></b></font></large> <i>Mode</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> create a new directory called <i>PathName</i> with mode <i>Mode</i>
<li> if <i>PathName</i> is e.g. <large><code>a/b/c/d</code></large>
<ul>
<li> all of the directories <large><code>a</code></large>, <large><code>b</code></large> and <large><code>c</code></large> must exist
<li> directory <large><code>c</code></large> must be writeable to the caller
<li> directory <large><code>d</code></large> must not already exist
</ul>
<li> the new directory contains two initial entries
<ul>
<li> <large><font color="#008800"><b><code>.</code></b></font></large> is a reference to itself
<li> <large><font color="#008800"><b><code>..</code></b></font></large> is a reference to its parent directory
</ul>
<li> returns 0 if successful, returns -1 and sets <large><code>errno</code></large> otherwise
</ul>
<br>
Example: &nbsp;<large><code>mkdir("newDir", 0755);</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>35/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int fsync(int</code></b></font></large> <i>FileDesc</i><large><font color="#008800"><b><code>)</code></b></font></large> 
<ul>
<li> ensure that data associated with <i>FileDesc</i> is written to storage
</ul>
<br>
Unix/Linux makes heavy use of buffering
<ul>
<li> data "written" to a file is initially stored in memory buffers
<li> eventually, it makes its way onto permanent storage device
<li> <large><code>fsync()</code></large> forces this to happen <i>now</i>
</ul>
<br>
Writing to permanent storage is typically an expensive operation
<ul>
<li> <large><code>fsync()</code></large> is normally called just once at process exit
</ul>
<br>
<small>
Note also: <large><code>fflush()</code></large> forces stdio buffers to be copied to kernel buffers
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File System Operations</span></td><td align='right'><small>36/37</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mount(char *</code></b></font></large><i>Source</i><large><font color="#008800"><b><code>, char *</code></b></font></large><i>Target</i><large><font color="#008800"><b><code>,
char *</code></b></font></large><i>FileSysType</i><large><font color="#008800"><b><code>, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
unsigned long</code></b></font></large> <i>Flags</i><large><font color="#008800"><b><code>, void *</code></b></font></large>data<large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> file systems normally exist on permanent storage devices
<li> <large><code>mount</code></large> attaches a file system to a specific location in the file hierarchy
<li> <i>Source</i> is often a storage device (e.g. <large><code>/dev/disk</code></large>)
<li> <i>Source</i> contains a file system (inode table, data chunks)
<li> <i>Target</i> (aka <em>mount point</em>) is a path in the file hierarchy
<li> <i>FileSysType</i> specifies a particular layout/drivers
<li> <i>Flags</i> specify various properties of the filesys <small>(e.g. read-only)</small>
</ul>
<br>
Example: &nbsp;<large><code>mount("/dev/disk5","/usr","ext3",MS_RDONLY,...)</code></large>
<p>
<small>(use <large><code>disk5</code></large> to hold the <large><code>/usr</code></large> file system as read-only ext3-type)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File System Summary</span></td><td align='right'><small>37/37</small></td></tr></table>
<p>
Operating systems provide a <em>file system</em>
<ul>
<li> as an abstraction over physical storage devices (e.g. disks)
<li> providing named access to chunks of related data (files)
<li> providing access (sequential/random) to the contents of files
<li> allowing files to be arranged in a hierarchy of directories
<li> providing control over access to files and directories
<li> managing other meta-data associated with files <small>(size, location, ...)</small>
</ul>
<br>
Operating systems also manage other resources
<ul>
<li> memory, &nbsp;processes, &nbsp;processor time, &nbsp;i/o devices, &nbsp;networking, ...
</ul>
<p><hr><p>
<small><small>Produced: 8 Aug 2019</small></small>
</body>
</html>

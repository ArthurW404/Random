<html>
<head>
<title>Week 07</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Week 07</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Memory Management</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory</span></td><td align='right'><small>2/65</small></td></tr></table>
<p>
Systems typically contain 4-16GB of volatile RAM
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware2-small.png]" src="Pics/opsys/hardware2-small.png">
</div><p>
Plus other smaller faster cache memory
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Processes</span></td><td align='right'><small>3/65</small></td></tr></table>
<p>
A <em>process</em> is an active computation, consisting of
<ul>
<li> RAM: code (read-only), data (read/write)
<li> Registers: program counter (PC) and other registers
<li> other management info, discussed later
</ul>
Multiple processes can be <em>active</em> simulataneously
<ul>
<li> typically not all loaded in RAM at once
<li> processes can be suspended (waiting)
<li> restoring a process: load code, data, registers
</ul>
Each process wants a view that it is the only one on the system
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory Management</span></td><td align='right'><small>4/65</small></td></tr></table>
<p>
Operating system provides a view of memory for individual processes
<p><div class='center'>
<img alt="[Diagram:Pics/memory/regions-small.png]" src="Pics/memory/regions-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>5/65</small></td></tr></table>
<p>
On a system with e.g. 1 CPU, 1 memory and 100's of processes
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-horde-small.png]" src="Pics/opsys/process-horde-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>6/65</small></td></tr></table>
<p>
The good-old-days ... one process/computation at a time
<ul>
<li> the process can use the entire memory
<li> addresses within process code are absolute
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/one-process-small.png]" src="Pics/opsys/one-process-small.png">
</div><p>
Or, if the process did not need the entire memory
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/one-small-process-small.png]" src="Pics/opsys/one-small-process-small.png">
</div><p>
Easy to implement by initialising <large><code>$sp</code></large> to <large><code>psize-4</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>7/65</small></td></tr></table>
<p>
Two processes loaded into memory at once
<ul>
<li> addreses in proc1 are absolute
<li> <b>all</b> addresses in proc2 need to be interpreted relative to <large><code>p1size</code></large>
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/two-process-small.png]" src="Pics/opsys/two-process-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>8/65</small></td></tr></table>
<p>
When <large><code>proc1</code></large> is loaded ...
<ul>
<li> copy code+data to memory, starting at address 0
<li> set stack pointer to <large><code>p1size-4</code></large>
</ul>
How to sort out <large><code>proc2</code></large> addresses? <small>(which assumes start addr = 0)</small>
<ul>
<li> "fix" them when process code+data is loaded
<ul>
<li> replace each address in code by <i>addr</i>+<large><code>p1size</code></large>
</ul>
<li> "map" addresses during execution
<ul>
<li> after a memory address is computed in machine code
<li> incremement it by <large><code>p1size</code></large> before accessing memory
<li> requires extra hardware <small>(holding <large><code>proc2</code></large>'s start address)</small>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>9/65</small></td></tr></table>
<p>
Consider a scenario with multiple processes loaded in memory:
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process-small.png]" src="Pics/opsys/multi-process-small.png">
</div><p>
If we do on-the-fly address mapping, we need to ...
<ul>
<li> remember <i>base</i> address for each process (process table)
<li> when process (re)starts, load <i>base</i> into mapping hardware
<li> interpret every address <i>addr</i> in program as <i>base</i>+<i>addr</i>
</ul>
Each process sees its own address space as [0 .. psize-1]
<ul>
<li> process can be loaded anywhere in memory without change
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>10/65</small></td></tr></table>
<p>
Consider the same scenario, but now we want to add a new process
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process2-small.png]" src="Pics/opsys/multi-process2-small.png">
</div><p>
The new process doesn't fit in any of the unused slots
<p>
Could move some process to make a single large slot
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process3-small.png]" src="Pics/opsys/multi-process3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>11/65</small></td></tr></table>
<p>
Alternative strategy: split new process memory over two regions
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process2-small.png]" src="Pics/opsys/multi-process2-small.png">
</div><p>
<p>
becomes
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process4-small.png]" src="Pics/opsys/multi-process4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>12/65</small></td></tr></table>
<p>
Implications for splitting process memory across physical memory
<ul>
<li> each chunk of process address space has its own <i>base</i>
<li> each chunk of process address space has its own <i>size</i>
<li> each chunk of process address space has its own <i>mem</i>ory location
</ul>
Need a table of process/address information to manage this, e.g.
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/proc-table-small.png]" src="Pics/opsys/proc-table-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>13/65</small></td></tr></table>
<p>
Under this scheme, address mapping calculation is complicated
</ul>
<p><pre>
Address processToPhysical(pid, addr)
{
   Chunk chunks[] = getChunkInfo(pid);
   for (int i = 0; i < nChunks(pid); i++) {
      Chunk *c = &chunks[i];
      if (addr >= c->base && addr < c->base+c->size)
         break;
   }
   uint offset = addr - c->base;
   return c->mem + offset;
}
</pre><p>
The above mapping <i>must</i> be done in hardware to be efficient.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>14/65</small></td></tr></table>
<p>
Address mapping would be simpler if all chunks were same size
<ul>
<li> call each chunk of address space a <em>page</em>
<li> all pages are the same size <i>P</i> (<i>PageSize</i> )
<li> process memory is spread across &nbsp;&lceil;<i>ProcSize</i>/<i>P</i> &rceil;&nbsp; pages
<li> page <i>i</i> has addresses <i>A</i> in range &nbsp;<i>i*P</i> &le; A &lt; <i>(i+1)*P</i>
</ul>
Also leads to a simpler address mapping table:
<ul>
<li> each process has an array of page entries
<li> each page entry contains start address of one chunk
<li> can compute index of relevant page entry by (<i>A / P</i> )
<li> can compute offset within page by (<i>A % P</i> )
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>15/65</small></td></tr></table>
<p>
Example of simple mapping table:
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/proc-table2-small.png]" src="Pics/opsys/proc-table2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Process&rarr;Physical Address Mapping</span></td><td align='right'><small>16/65</small></td></tr></table>
<p>
Consider process <large><code>p7</code></large> from previous slide
<ul>
<li> has three pages: p0 @ 5000, p1 @ 3000, p2 @ 1000
</ul>
Page size is 1000
<p>
For each of the following process addresses, where is it located in physical memory?
<ol type="a">
<li> <large><code>0x0000</code></large> = 0
<li> <large><code>0x0080</code></large> = 128
<li> <large><code>0x0400</code></large> = 1024
<li> <large><code>0x0888</code></large> = 2184
<li> <large><code>0x1000</code></large> = 4096
</ol>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory Management Review</span></td><td align='right'><small>17/65</small></td></tr></table>
<p>
Reminder: process addresses &harr; physical addresses
<ul>
<li> process has (virtual) address space 0..N-1 bytes
<li> memory has (physical) address space 0..M-1 bytes
<li> both address spaces partitioned in P byte pages
<li> process address space contains K = &lceil;N/P&rceil; <em>pages</em>
<li> memory address space has L = &lceil;M/P&rceil; <em>frames</em>
</ul>
Mapping:
<ul>
<li> takes address (Vaddr) in process address space
<li> returns address (Paddr) in memory address space
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Address Mapping</span></td><td align='right'><small>18/65</small></td></tr></table>
<p>
Mapping from process address to physical address:
<p><pre>
Address processToPhysical(pid, Vaddr)
{
   PageInfo pages[] = getPageInfo(pid);
   uint pageno = Vaddr / PageSize;  <comment><tiny>// int div</tiny></comment>
   uint offset = Vaddr % PageSize;
   return pages[pageno].mem + offset;
}
</pre><p>
<br>
Computation of <large><code>pageno</code></large>,<large><code>offset</code></large> is efficient if <i>Pagesize == 2<sup>n</sup></i>
<p><br>
Note that we assume <large><code>PageInfo</code></large> entries with more information ....
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Address Mapping</span></td><td align='right'><small>19/65</small></td></tr></table>
<p>
Page table entries typically do not store physical address
<ul>
<li> to save space, just store frame number F
<li> compute physical address via (P * F + Offset)
</ul>
If P == 2<sup>n</sup>, then address mapping becomes
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/addr-mapping-small.png]" src="Pics/opsys/addr-mapping-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 2: Address Mapping</span></td><td align='right'><small>20/65</small></td></tr></table>
<p>
Rewrite the address mapping function to exploit &nbsp;P = 2<sup>12</sup>
<br><br>
<p><pre>
Address processToPhysical(pid, Vaddr)
{
   PageInfo pages[] = getPageInfo(pid);
   uint pageno = Vaddr / P;
   uint offset = Vaddr % P;
   return pages[pageno].mem + offset;
}
</pre><p>
<br>
Assume that <large><code>PageInfo</code></large> = (status,frameNo)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Virtual Memory</span></td><td align='right'><small>21/65</small></td></tr></table>
<p>
A side-effect of this type of virtual&rarr;physical address mapping
<ul>
<li> don't need to load all of process's pages up-front
<li> start with a small memory "footprint" <small>(e.g. <large><code>main</code></large> + stack top)</small>
<li> load new process address pages into memory <i>as needed</i>
<li> grow up to the size of the (available) physical memory
</ul>
The strategy of ...
<ul>
<li> dividing process memory space into fixed-size pages
<li> on-demand loading of process pages into physical memory
</ul>
is called <em>virtual memory</em>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>22/65</small></td></tr></table>
<p>
Pages/frames are typically 512B .. 8KB in size
<p>
In a 4GB memory, would have &cong;4 million &times; 1KB frames
<p>
Each frame can hold one page of process address space
<p>
Leads to a memory layout like this <small>(with <i>L</i> total pages of physical memory):</small>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/all-pages-small.png]" src="Pics/opsys/all-pages-small.png">
</div><p>
When a process completes, all of its frames are released for re-use
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>23/65</small></td></tr></table>
<p>
How to arrange mapping process address &rarr; physical address?
<p>
Consider a per-process page table, e.g.
<ul>
<li> each page table entry (PTE) contains
<ul>
<li> page status ... Loaded, IsModified, NotLoaded
<li> frame number of page (if Loaded)
<li> ... maybe others ... <small>(e.g. last accessed time)</small>
</ul>
<li> we need <big>&lceil;</big><i>ProcSize</i> /<i>PageSize</i><big>&rceil;</big> entries in this table
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>24/65</small></td></tr></table>
<p>
Example of page table for one process:
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-pages2-small.png]" src="Pics/opsys/process-pages2-small.png">
</div><p>
<br>
Timestamps show when page was loaded.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>25/65</small></td></tr></table>
<p>
Virtual address to physical address mapping <small>(more detail)</small>:
<p><pre><small>
typedef struct {char status, uint frameNo, ...} PageData;

PageData *AllPageTables[maxProc];
    <comment>// one entry for each process</comment>

Address processToPhysical(pid, Vaddr)
{
   PageData *PageTable = AllPageTables[pid];
   uint pageno = PageNumberFrom(Vaddr);
   uint offset = OffsetFrom(Vaddr);
   if (PageTable[pageno].status != Loaded) {
      <comment>// load page into free frame</comment>
      <comment>// set PageTable[pageno]</comment>
   }
   uint frame = PageTable[pageno].frameNo;
   return frame * P + offset;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>An Aside: Working Sets</span></td><td align='right'><small>26/65</small></td></tr></table>
<p>
Consider a new process commencing execution ...
<ul>
<li> initially has zero pages loaded
<li> load page containing code for <large><code>main()</code></large>
<li> load page for <large><code>main()</code></large>'s stack frame
<li> load other pages when process references address within page
</ul>
Do we ever need to load all process pages at once?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... An Aside: Working Sets</span></td><td align='right'><small>27/65</small></td></tr></table>
<p>
From observations of running programs ...
<ul>
<li> in any given window of time,<br>
	a process is likely to access only a small subset of its pages
</ul>
Known as the <em>working set</em> model &nbsp; <small>(cf <em>locality of reference</em>)</small>
<p>
Only need to hold, at a given time, the process's working set of pages
<p>
Implications:
<ul>
<li> if each process has a relatively small working set,<br>
	can hold pages for many active processes in memory at same time
<li> if only need to hold some of process's pages in memory,<br>
	process address space can be larger than physical memory
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 3: Reference Locality</span></td><td align='right'><small>28/65</small></td></tr></table>
<p>
Consider the following data structure
<p><pre>
typedef struct { int acc[3]; int vel[3]; } Point
Point p[10000];
</pre><p>
and two functions to clear all the values in the array.
<p>
Discuss the locality of data reference in each of these functions:
<p><pre><small>
void clear1(point *p, int n)
{
   int i,j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < 3; j++) p[i].acc[j] = 0;
      for (j = 0; j < 3; j++) p[i].vel[j] = 0;
   }
}
void clear2(point *p, int n)
{
   int i,j;
   for (j = 0; j < 3; j++) {
      for (i = 0; i < n; i++) p[i].acc[j] = 0;
      for (i = 0; i < n; i++) p[i].vel[j] = 0;
   }
}
</small></pre><p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/points-array-small.png]" src="Pics/opsys/points-array-small.png">
</div><p>
<br>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Virtual Memory</span></td><td align='right'><small>29/65</small></td></tr></table>
<p>
We say that we "load" pages into physical memory
<p>
But where are they loaded from?
<ul>
<li> code is loaded from the executable file stored on disk
<li> global data is also initially loaded from here
<li> dynamic (heap, stack) data is created in memory
</ul>
<br>
Consider a process whose address space exceeds physical memory
<p>
The pages of dynamic data not currently in use
<ul>
<li> may need to be removed temporarily from memory &nbsp;<small>(see later)</small>
<li> thus would also be saved on disk and restored from disk
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>30/65</small></td></tr></table>
<p>
We can imagine that a process's address space ...
<ul>
<li> exists on disk for the duration of the process's execution
<li> and only some parts of it are in memory at any given time
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-pages-small.png]" src="Pics/opsys/process-pages-small.png">
</div><p>
<p>
Transferring pages between disk&harr;memory is <b>very</b> expensive
<ul>
<li> need to ensure minimal reading from / writing to disk
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>31/65</small></td></tr></table>
<p>
Per-process page table, allowing for some pages to be not loaded
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/page-table3-small.png]" src="Pics/opsys/page-table3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>32/65</small></td></tr></table>
<p>
Recall the address mapping process with per-process page tables
<p><pre><small>
Address processToPhysical(pid, Vaddr)
{
   PageData *PageTable = AllPageTables[pid];
   uint pageno = PageNumberFrom(Vaddr);
   uint offset = OffsetFrom(Vaddr);
   if (PageTable[pageno].status != Loaded) {
      <comment>// load page into free frame</comment>
      <comment>// set PageTable[pageno]</comment>
   }
   uint frame = PageTable[pageno].frameNo;
   return frame * P + offset;
}
</small></pre><p>
What to do if the page is not loaded?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Page Faults</span></td><td align='right'><small>33/65</small></td></tr></table>
<p>
Requesting a non-loaded page generates a <em>page fault</em>.
<p>
One approach to handling a page fault ...
<ul>
<li> find a free (unused) page frame in memory and use that
</ul>
<p><pre>
   <comment>// load page into a free frame ...</comment>
   else {
      frameno    = getFreeFrame();
      p->frameNo = frameno;
      p->status  = Loaded;
   }
</pre><p>
Assumes that we have a way of quickly identifying free frames
<p>
Commonly handled via a <em>free list</em>
<p>
<small>
Reminder: frames allocated to a process become <i>free</i> when process exits
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Faults</span></td><td align='right'><small>34/65</small></td></tr></table>
<p>
What happens if there are currently no free page frames
<p>
What does <large><code>getFreeFrame()</code></large> do?
<p>
Possibilities:
<ul>
<li> <em>suspend</em> the requesting process until a page is freed
<li> <em>replace</em> one of the currently loaded/used pages
</ul>
Suspending requires the process manager to
<ul>
<li> maintain a (priority) queue of processes waiting for pages
<li> dequeue and schedule the first process on queue when page freed
</ul>
Will discuss process queues further in next section.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Page Replacement</span></td><td align='right'><small>35/65</small></td></tr></table>
<p>
What happens when a page is replaced?
<ul>
<li> if it's been modified since loading, save to disk ** <br>
   <small>(in the disk-based virtual memory space of the running process)</small>
<li> grab its frame number and give it to the requestor
</ul>
How to decide which frame should be replaced?
<ul>
<li> define a "usefulness" measure for each frame
<li> grab the frame with lowest usefulness
   <small>(e.g. priority queue?)</small>
</ul>
<br>
** we need a flag to indicate whether a page is modified
<p><pre>
#define NotLoaded   0x00000000
#define Loaded      0x00000001
#define IsModified  0x00000002
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Replacement</span></td><td align='right'><small>36/65</small></td></tr></table>
<p>
Factors to consider in deciding which page to replace
<ul>
<li> best page is one that won't be used again by its process
<li> prefer pages that are read-only &nbsp;<small>(no need to write to disk)</small>
<li> prefer pages that are unmodified &nbsp;<small>(no need to write to disk)</small>
<li> prefer pages that are used by only one process &nbsp;<small>(see later)</small>
</ul>
OS can't predict whether a page will be required again by its process
<p>
But we do know whether it has been used recently <small>(if we record this)</small>
<p>
Useful heuristic: <em>LRU replacement</em>
<ul>
<li> a page not used recently may not be needed again soon
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Replacement</span></td><td align='right'><small>37/65</small></td></tr></table>
<p>
Factors for choosing best page to replace are <i>heuristic</i>
<p>
What happens if ...
<ul>
<li> we replace a page which is soon used again
<li> this causes us to replace another page
<li> and the second page is soon used again ......
</ul>
<em>Thrashing</em> = constantly swapping pages in and out of memory
<p>
The working set model plus LRU helps avoid <em>thrashing</em>
<ul>
<li> recently used page is likely to be used again soon
<li> not recently used page is unlikely to be used again soon
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Replacement</span></td><td align='right'><small>38/65</small></td></tr></table>
<p>
LRU is one replacement strategy. Others include:
<p>
<em>First-in-first-out</em> (FIFO)
<ul>
<li> page frames are entered into a queue when loaded
<li> page replacement uses the frame from the front of the queue
</ul>
<em>Clock sweep</em>
<ul>
<li> uses a reference bit for each frame, updated when page is used
<li> maintains a circular list of allocated frames
<li> uses a "clock hand" which iterates over page frame list
<ul>
<li> skipping and resetting reference bit in all referenced pages
</ul>
<li> page replacement uses first-found unreferenced frame
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 4: Page Replacement</span></td><td align='right'><small>39/65</small></td></tr></table>
<p>
Show how the page frames and page tables change when
<ul>
<li> there are 4 page frames in memory
<li> the process has 6 pages in its virtual address space
<li> a LRU page replacement strategy is used
</ul>
For each of the following sequences of virtual page accesses
<ol>
<li> 0, 5, 0, 0, 5, 1, 5, 1, 2, 4, 3, 3, 4, 2, 5, 3, 2, ...
<li> 5, 0, 0, 0, 5, 1, 1, 5, 1, 5, 2, 2, 3, 0, 0, 5, ...
</ol>
Assume that all PTEs and frames are initially empty/unused
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Virtual Memory </span></td><td align='right'><small>40/65</small></td></tr></table>
<p>
Page tables (PTs) revisited ...
<ul>
<li> a virtual address space with <i>K</i> pages needs <i>K</i> PT entries
<li> since <i>K</i> may be large, do not want to store whole PT
<li> especially since working set tells us <i>n</i> &ll; <i>K</i> needed at once
</ul>
One possibility: PT with <i>n</i> < <i>K</i> entries and hashing
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/page-table4-small.png]" src="Pics/opsys/page-table4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory </span></td><td align='right'><small>41/65</small></td></tr></table>
<p>
Alternative strategy: multi-level page tables
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/page-table5-small.png]" src="Pics/opsys/page-table5-small.png">
</div><p>
<br>
<small>
Effective because not all pages in virtual address space are required <br>
(e.g. the pages between the top of the heap and the bottom of the stack)
<small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory </span></td><td align='right'><small>42/65</small></td></tr></table>
<p>
Virtual memory allows sharing of read-only pages (e.g. library code)
<ul>
<li> several processes include same frame in virtual address space
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/shared-pages-small.png]" src="Pics/opsys/shared-pages-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Cache Memory</span></td><td align='right'><small>43/65</small></td></tr></table>
<p>
<em>Cache memory</em> = small*, fast memory* close to CPU
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware3-small.png]" src="Pics/opsys/hardware3-small.png">
</div><p>
<p><br>
Small = MB,  &nbsp; Fast = 5 &times; RAM
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Cache Memory</span></td><td align='right'><small>44/65</small></td></tr></table>
<p>
Cache memory
<ul>
<li> holds parts of RAM that are (hopefully) heavily used
<li> transfers data to/from RAM in blocks (<em>cache blocks</em>)
<li> memory reference hardware first looks in cache
<ul>
<li> if required address is there, use its contents
<li> if not, get it from RAM and put in cache
<li> possibly replacing an existing cache block
</ul>
<li> replacement strategies have similar issues to virtual memory
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory Management Hardware</span></td><td align='right'><small>45/65</small></td></tr></table>
<p>
Address translation is very important/frequent
<ul>
<li> provide specialised hardware (MMU) to do it efficiently
<li> sometimes located on CPU chip, sometimes separate
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware4-small.png]" src="Pics/opsys/hardware4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management Hardware</span></td><td align='right'><small>46/65</small></td></tr></table>
<p>
TLB = translation lookaside buffer
<ul>
<li> lookup table containing (virtual,physical) address pairs
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/TLB-small.png]" src="Pics/opsys/TLB-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Process Management</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Processes</span></td><td align='right'><small>48/65</small></td></tr></table>
<p>
A <em>process</em> is an instance of an executing program
<p>
Each process has an <em>execution state</em>, defined by
<ul>
<li> current execution point &nbsp; (PC register)
<li> current values of CPU registers
<li> current contents of its virtual address space
<li> information about open files, sockets, etc.
</ul>
To manage processes, the operating system also maintains
<ul>
<li> process page table &nbsp; <small>(i.e. virtual memory mapping)</small>
<li> process metadata &nbsp; <small>(e.g. execution time, priority, ...)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Processes</span></td><td align='right'><small>49/65</small></td></tr></table>
<p>
On a typical modern operating system
<ul>
<li> multiple processes are active "simultaneously" &nbsp; (<em>multi-tasking</em>)
</ul>
<br>
The operating system provides each process with
<ul>
<li> control-flow independence
<small>
<ul>
<li> each process executes as if the only process running on the machine
</ul>
</small>
<li> private address space
<small>
<ul>
<li> each process has its own address space (N bytes, addressed 0..N-1)
</ul>
</small>
</ul>
<br>
<em>Process management</em> is a critical OS functionality
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Processes</span></td><td align='right'><small>50/65</small></td></tr></table>
<p>
Control-flow independence <small>("I am the only process, and I run until I finish")</small>
<p>
When there are multiple processes running on the machine
<ul>
<li> each process uses the CPU until <em>pre-empted</em> or exits
<li> then another process uses the CPU until it too is pre-empted
<li> eventually, the first process will get another run on the CPU
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/processes-small.png]" src="Pics/opsys/processes-small.png">
</div><p>
Overall impression: three programs running simultaneously
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Processes</span></td><td align='right'><small>51/65</small></td></tr></table>
<p>
What can cause a process to be pre-empted?
<ul>
<li> it runs "long enough" and the OS replaces it by a waiting process
<li> it attempts to perform a long-duration task, like input/output
</ul>
On pre-emption ...
<ul>
<li> the process's entire dynamic state must be saved (incl PC)
<li> the process is flagged as temporarily suspended
<li> it is placed on a process (priority) queue for re-start
</ul>
On resuming, the state is restored and the process starts at saved PC
<p><br>
Overall impression: I ran until I finished all my computation
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Process Management</span></td><td align='right'><small>52/65</small></td></tr></table>
<p>
How does the OS manage multiple simultaneous processes?
<p>
For each process, maintains <em>context</em>  (or <em>state</em>)
<ul>
<li> static information: program code and constant data
<li> dynamic state: heap, stack, registers, program counter
<li> OS-supplied state: environment variables, stdin, stdout
</ul>
At pre-emption, performs a <em>context switch</em>
<ul>
<li> save context for one process
<li> restore context for another process
</ul>
<br>
Non-static process context is held in a <em>process control block</em>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process Management</span></td><td align='right'><small>53/65</small></td></tr></table>
<p>
Typical contents of <em>process control block</em> (PCB)
<ul>
<li> identifier: unique process ID &nbsp;<small>(<large><code>int</code></large>)</small>
<li> status: &nbsp;running, &nbsp;ready, &nbsp;suspended, &nbsp;exited
<ul>
<li> if suspended, event being waited for
</ul>
<li> state: registers (including PC)
<li> privileges: owner, group
<li> memory management info: <small>(reference to)</small> page table
<li> accounting: CPU time used, amount of I/O done
<li> I/O: open file descriptors
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process Management</span></td><td align='right'><small>54/65</small></td></tr></table>
<p>
The operating system maintains a table of PCBs
<ul>
<li> one for each currently active process &nbsp; <small>(indexed by process ID?)</small>
</ul>
The OS <em>scheduler</em>
<ul>
<li> maintains a queue of runnable processes
<li> ordered based on information in the PCBs
</ul>
When current process is pre-empted or suspends, the scheduler
<ul>
<li> saves state of process, updates PCB entry
<li> selects next process to run, and re-starts it
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unix/Linux Processes</span></td><td align='right'><small>55/65</small></td></tr></table>
<p>
Environment for processes running on Unix/Linux systems
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/unix-process-env-small.png]" src="Pics/opsys/unix-process-env-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>56/65</small></td></tr></table>
<p>
Unix provides a range of tools for manipulating processes
<p>
Commands:
<ul>
<li> <large><font color="#008800"><b><code>sh</code></b></font></large> ... for creating processes via object-file name
<li> <large><font color="#008800"><b><code>ps</code></b></font></large> ... show process information
<li> <large><font color="#008800"><b><code>w</code></b></font></large> ... show per-user process information
<li> <large><font color="#008800"><b><code>top</code></b></font></large> ... show high-cpu-usage process information
<li> <large><font color="#008800"><b><code>kill</code></b></font></large> ... send a signal to a process
</ul>
System calls:
<ul>
<li> <large><code>fork()</code></large>, &nbsp; <large><code>execve()</code></large>, &nbsp; <large><code>_exit()</code></large>, &nbsp; etc.
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 5: Process Information</span></td><td align='right'><small>57/65</small></td></tr></table>
<p>
How can I find out ...
<ul>
<li> what processes I currently have running
<li> what are all of the processes running on the system
<li> what are the top CPU-using processes
<li> who's logged in and what they're doing
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>58/65</small></td></tr></table>
<p>
Information associated with processes (PCB):
<ul>
<li> <large><code>pid</code></large> ... process id
<li> <large><code>ruid</code></large>, <large><code>euid</code></large> ... real and effective user id
<li> <large><code>rgid</code></large>, <large><code>egid</code></large> ... real and effective group id
<li> current working directory
<li> accumulated execution time (user/kernel)
<li> user file descriptor table
<li> information on how to react to signals
<li> pointer to process page table
<li> process state ... running, suspended, asleep, etc.
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>59/65</small></td></tr></table>
<p>
Process info is split across process table entry and user structure
<p><br>
<em>Process table</em> = kernel data structure describing all processes
<ul>
<li> memory-resident since very heavily used
<li> contains PCB info as described above
<li> content of PCB entries is critical for scheduler
</ul>
<br>
<em>User structure</em> = kernel data structure describing run-time state
<ul>
<li> holds info not needed when process swapped out
<li> e.g. execution state <small>(registers, signal handlers, file descriptors, ...)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>60/65</small></td></tr></table>
<p>
Every process in Unix/Linux is allocated a process ID &nbsp;(PID)
<ul>
<li> a +ve integer, unique among currently executing processes
<li> with type <large><font color="#008800"><b><code>pid_t</code></b></font></large> &nbsp; <small>(defined in &lt;unistd.h&gt;)</small>
<li> process 0 is the <em>idle</em> process &nbsp;<small>(always runnable)</small>
<li> process 1 is <large><code>init</code></large> &nbsp;<small>("the system")</small>
<li> low-numbered processes are typically system-related
<li> regular processes have PID in the range 300 .. MaxPid &nbsp;<small>(e.g. 2<sup>16</sup>)</small>
</ul>
Process 0 is not a real process &nbsp; <small>(it's a kernel artefact)</small>
<small>
<ul>
<li> it exists to ensure that there is always at least one process to run
</ul>
On older Unix systems, process 0 was called <large><code>sched</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>61/65</small></td></tr></table>
<p>
Each process has a <em>parent process</em>
<ul>
<li> typically, the process that created the current process
</ul>
A process may have <em>child processes</em>
<ul>
<li> any processes that it created
</ul>
<br>
Process 1 is created at system startup
<p>
If a process' parent dies, it is inherited by process 1
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>62/65</small></td></tr></table>
<p>
Processes are collected into <em>process groups</em>
<ul>
<li> each group is associated with a unique PGID
<li> with type <large><font color="#008800"><b><code>pid_t</code></b></font></large> &nbsp; <small>(defined in &lt;unistd.h&gt;)</small>
<li> a child process belongs to the process group of its parent
<li> a process can create its own process group, <br>
	or can move into another process group
</ul>
Process groups allow
<ul>
<li> OS to keep track of groups of processes working together
<li> distribution of signals to a set of related processes
<li> management of processes for job control &nbsp;(control-Z)
<li> management of processes within pipelines
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>System Calls (and Failure)</span></td><td align='right'><small>63/65</small></td></tr></table>
<p>
Reminder ...
<p>
System calls are requests for the OS to do something, e.g.
<ul>
<li> create a new process, send a signal, read some data, etc.
</ul>
Sometimes the request cannot be completed, e.g.
<ul>
<li> invalid PID or file descriptor, resources exhausted, etc.
</ul>
In such cases
<ul>
<li> the system call returns -1
<li> the value of the global variable <large><code>errno</code></large> is set
</ul>
In many (most?) cases, a failed system call is a fatal error.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... System Calls (and Failure)</span></td><td align='right'><small>64/65</small></td></tr></table>
<p>
How to deal with failed system calls?
<p>
Generally, print an error and terminate the process.
<p>
A useful strategy: a wrapper function
<ul>
<li> with same arguments/returns as system call
<li> catches and reports the error
<li> only ever returns with a valid result
</ul>
Not always appropriate, e.g.
<ul>
<li> failure of <large><code>open()</code></large> best handled by caller
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... System Calls (and Failure)</span></td><td align='right'><small>65/65</small></td></tr></table>
<p>
Example: a wrapper function for <large><code>read()</code></large>
<p><pre>
size_t Read(int fd, void *buf, size_t nbytes)
{
   ssize_t nread = read(fd, buf, nbytes);
   if (nread < 0) {
      perror("read() failed");
      exit(1);
   }
   return (size_t)nread;
}
</pre><p>
Use like <large><code>read()</code></large> but only get non-negative returns.
<p><hr><p>
<small><small>Produced: 8 Aug 2019</small></small>
</body>
</html>

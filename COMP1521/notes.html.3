<html>
<head>
<title>Week 04</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Week 04</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Programming</span></td><td align='right'><small>1/58</small></td></tr></table>
<p>
Writing directly in MIPS assembler is difficult (impossible?)
<p>
Strategy for producing likely correct MIPS code
<ul>
<li> develop the solution in C
<li> map to "simplified" C
<li> translate each simplified C statement to MIPS instructions
</ul>
Simplified C
<ul>
<li> does <em>not</em> have <large><code>while</code></large>, <large><code>switch</code></large>, complex expressions
<li> <em>does</em> have simple <large><code>if</code></large>, <large><code>goto</code></large>, one-operator expressions
<li> does <em>not</em> have function calls and auto local variables
<li> <em>does</em> have jump-and-remember-where-you-came-from
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Programming</span></td><td align='right'><small>2/58</small></td></tr></table>
<p>
Example translating C to MIPS:
<p><pre>
C             Simplified C   MIPS Assembler
------------  ------------   --------------
int x = 5;    int x = 5;     x:  .word 5
int y = 3;    int y = 3;     y:  .word 3
int z;        int z;         z:  .space 4
              int t;         <span class="comment">...</span>
                             lw  $t0, x
                             lw  $t1, y
z = 5*(x+y);   t = x+y;      add $t0, $t0, $t1
                             li  $t1, 5
               t = 5*t;      mul $t0, $t0, $t1
               z = t;        sw  $t0, z
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Programming</span></td><td align='right'><small>3/58</small></td></tr></table>
<p>
Simplified C makes extensive use of
<ul>
<li> <font color='#009900'>labels</font> ... symbolic name for C statement
<li> <font color='#CC0000'>goto</font> ... transfer control to labelled statement
</ul>
Example:
<p><pre>
Standard C            Simplified C
------------------    ------------------
i = 0; n = 0;         i = 0; n = 0; 
while (i < 5) {       <font color='#009900'>loop:</font>
   n = n + i;           if (i >= 5) <font color='#CC0000'>goto</font> <font color='#009900'>end</font>;
   i++;                 n = n + i;
}                       i++;
                        <font color='#CC0000'>goto</font> <font color='#009900'>loop</font>;
                      <font color='#009900'>end:</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Rendering C in MIPS</span></td><td align='right'><small>4/58</small></td></tr></table>
<p>
C provides expression evaluation and assignment, e.g.
<ul>
<li> <large><code>x = (1 + y*y) / 2; &nbsp; z = 1.0 / 2;</code></large> ...
</ul>
MIPS provides register-register operations, e.g.
<ul>
<li> <large><code>move R<sub>d</sub>,R<sub>s</sub></code></large>, &nbsp; <large><code>li R<sub>d</sub>,Const</code></large>, &nbsp; <large><code>add</code></large>, <large><code>div</code></large>, <large><code>and</code></large>, ...
</ul>
C provides a range of control structures
<ul>
<li> sequence (<large><code>;</code></large>), <large><code>if</code></large>, <large><code>while</code></large>, <large><code>for</code></large>, <large><code>break</code></large>, <large><code>continue</code></large>, ...
</ul>
MIPS provides testing/branching instructions
<ul>
<li> <large><code>seq</code></large>, <large><code>slti</code></large>, <large><code>sltu</code></large>, ..., <large><code>beq</code></large>, <large><code>bgtz</code></large>, <large><code>bgezal</code></large>, ..., <large><code>j</code></large>, <large><code>jr</code></large>, <large><code>jal</code></large>, ...
</ul>
We need to render C's structures in terms of testing/branching
<p>
Sequence is easy &nbsp; <large><code>S<sub>1</sub> ; S<sub>2</sub></code></large> &nbsp; &rarr; &nbsp; <large><code>mips(S<sub>1</sub>) mips(S<sub>2</sub>)</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Rendering C in MIPS</span></td><td align='right'><small>5/58</small></td></tr></table>
<p>
Simple example of rendering assignment and sequence:
<p><pre>
int x;        x: .space 4
int y;        y: .space 4

x = 2;           li   $t0, 2
                 sw   $t0, x

y = x;           lw   $t0, x
                 sw   $t0, y

y = y+3;         lw   $t0, y
                 addi $t0, $t0, 3
                 sw   $t0, y
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Rendering C in MIPS</span></td><td align='right'><small>6/58</small></td></tr></table>
<p>
Expression evaluation involves
<ul>
<li> describing the process as a sequence of binary operations
<li> managing data flow between the operations
</ul>
Example:
<p><pre>
# x = (1 + y*y) / 2
<span class="comment"># assume x and y exist as labels in .data</span>
  lw   $t0, y          <span class="comment"># t0 = y</span>
  mul  $t0, $t0, $t0   <span class="comment"># t0 = t0*t0</span>
  addi $t0, $t0, 1     <span class="comment"># t0 = t0+1</span>
  li   $t1, 2          <span class="comment"># t1 = 2</span>
  div  $t0, $t1        <span class="comment"># Lo = t0/t1 (int div)</span>
  mflo $t0             <span class="comment"># t0 = Lo</span>
  sw   $t0, x          <span class="comment"># x = t0</span>
</pre><p>
<small>
It is useful to minimise the number of registered involved in the evaluation
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Expression Evaluation</span></td><td align='right'><small>7/58</small></td></tr></table>
<p>
Write a MIPS program to evaluate the expression:
<p><pre>
(x*x + y*y) / (x+y)
</pre><p>
where ...
<ul>
<li> <large><code>x</code></large> is implemented by register <large><code>$s1</code></large>
<li> <large><code>y</code></large> is the label of a memory location
</ul>
<p>
Leave the result of the expression in <large><code>$v0</code></large>
<p>
Start by writing a simplified C version.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Conditional Statements</span></td><td align='right'><small>8/58</small></td></tr></table>
<p>
Conditional statements (e.g. <large><code>if</code></large>)
<p><pre>
Standard C                Simplified C
------------------------  ------------------------
                          <font color='#009900'>if_stat:</font>
if (<i>Cond</i>)                   t0 = (<i>Cond</i>)
   { <i>Statements<sub>1</sub></i> }          if (t0 == 0)
else                           goto else_part;
   { <i>Statements<sub>2</sub></i> }          <i>Statements<sub>1</sub></i>
                            goto end_if;
                         <font color='#009900'>else_part:</font>
                            <i>Statements<sub>2</sub></i>
                         <font color='#009900'>end_if:</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>9/58</small></td></tr></table>
<p>
Conditional statements (e.g. <large><code>if</code></large>)
<p><pre>
                         <font color='#009900'>if_stat:</font>
if (<i>Cond</i>)                  t0 = evaluate (<i>Cond</i>)
   { <i>Statements<sub>1</sub></i> }         <b>beqz</b> $t0, <font color='#009900'>else_part</font>
else                       execute <i>Statements<sub>1</sub></i>
   { <i>Statements<sub>2</sub></i> }         <b>j</b>    <font color='#009900'>end_if</font>
                         <font color='#009900'>else_part:</font>
                           execute <i>Statements<sub>2</sub></i>
                         <font color='#009900'>end_if:</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>10/58</small></td></tr></table>
<p>
Example of if-then-else:
<p><pre><small>
int x;           x is $t0
int y;           y is $t1
char z;          z is $a0

x = getInt();    li   $v0, 5
                 syscall
                 move $t0, $v0

y = getInt();    li   $v0, 5
                 syscall
                 move $t1, $v0

if (x == y)      bne  $t0, $t1, setN
   z = 'Y';    setY:
                 li   $a0, 'Y'
                 j    print
else           setN:
   z = 'N';      li   $a0, 'N'
                 j    print    <comment># redundant</comment>
               print:
putChar(z);      li   $v0, 11
                 syscall
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 2: Mapping <tt>if</tt></span></td><td align='right'><small>11/58</small></td></tr></table>
<p>
Translate the following C statement to MIPS
<p><pre>
if (mark < 50)
   grade = 'F';     <span class="comment">// i.e. FL</span>
else if (mark < 65)
   grade = 'P';     <span class="comment">// i.e. PS</span>
else if (mark < 75)
   grade = 'C';     <span class="comment">// i.e. CR</span>
else if (mark < 85)
   grade = 'D';     <span class="comment">// i.e. DN</span>
else
   grade = 'H';     <span class="comment">// i.e. HD</span>
</pre><p>
Assume that <large><code>mark</code></large> and <large><code>grade</code></large> are defined in <large><code>.data</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>12/58</small></td></tr></table>
<p>
Could make <large><code>switch</code></large> by first converting to <large><code>if</code></large>
<p><pre>
switch (Expr) {              tmp = Expr;
case Val<sub>1</sub>:                   if (tmp == Val<sub>1</sub>)
   Statements<sub>1</sub> ; break;         { Statements<sub>1</sub>; }
case Val<sub>2</sub>:                   else if (tmp == Val<sub>2</sub>
case Val<sub>3</sub>:                            || tmp == Val<sub>3</sub>
case Val<sub>4</sub>:                            || tmp == Val<sub>4</sub>)
   Statements<sub>2</sub> ; break;         { Statements<sub>2</sub>; }
case Val<sub>5</sub>:                   else if (tmp == Val<sub>5</sub>)
   Statements<sub>3</sub> ; break;         { Statements<sub>3</sub>; }
default:                     else
   Statements<sub>4</sub> ; break;         { Statements<sub>4</sub>; }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>13/58</small></td></tr></table>
<p>
Jump table: an alternative implementation of <large><code>switch</code></large>
<ul>
<li> works best for small, dense range of case values (e.g. 1..10)
</ul>
<p><pre><small>
                             jump_tab:
                                .word c1, c2, c2, c2, c3
                             switch:
                                 t0 = evaluate Expr
switch (Expr) {                  if (t0 < 1 || t0 > 5)
case 1:                             jump to default
   Statements<sub>1</sub> ; break;          dest = jump_tab[(t0-1)*4]
case 2:                          jump to dest
case 3:                      c1: execute Statements<sub>1</sub> 
case 4:                          jump to end_switch
   Statements<sub>2</sub> ; break;      c2: execute Statements<sub>2</sub>
case 5:                          jump to end_switch
   Statements<sub>3</sub> ; break;      c3: execute Statements<sub>3</sub>
default:                         jump to end_switch
   Statements<sub>4</sub> ; break;      default:
}                                execute Statements<sub>4</sub>
                             end_switch:
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Boolean Expressions</span></td><td align='right'><small>14/58</small></td></tr></table>
<p>
Boolean expressions in C are short circuit
<p>
<p><pre>
(Cond<sub>1</sub> && Cond<sub>2</sub> && ... && Cond<sub>n</sub>)
</pre><p>
Evaluates by 
<ul>
<li> evaluate <large><code>Cond<sub>1</sub></code></large>; if 0 then return 0 for whole expression
<li> evaluate <large><code>Cond<sub>2</sub></code></large>; if 0 then return 0 for whole expression
<li> ...
<li> evaluate <large><code>Cond<sub>n</sub></code></large>; if 0 then return 0 for whole expression
<li> otherwise, return 1
</ul>
In C, any non-zero value is treated as true; MIPS tends to use 1 for true
<p>
C99 standard defines return value for booleans expressions as 0 or 1
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Boolean Expressions</span></td><td align='right'><small>15/58</small></td></tr></table>
<p>
Similarly for disjunctions
<p>
<p><pre>
(Cond<sub>1</sub> || Cond<sub>2</sub> || ... || Cond<sub>n</sub>)
</pre><p>
Evaluates by
<ul>
<li> evaluate <large><code>Cond<sub>1</sub></code></large>; if !0 then return 1 for whole expression
<li> evaluate <large><code>Cond<sub>2</sub></code></large>; if !0 then return 1 for whole expression
<li> ...
<li> evaluate <large><code>Cond<sub>n</sub></code></large>; if !0 then return 1 for whole expression
<li> otherwise, return 1
</ul>
In C, any non-zero value is treated as true; MIPS tends to use 1 for true
<p>
C99 standard defines return value for booleans expressions as 0 or 1
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 3: Implementing Conjunctions</span></td><td align='right'><small>16/58</small></td></tr></table>
<p>
Implement the following in MIPS assembler
<p><pre>
if (x != 0 && y != 0 && x > y)
   { statements<sub>1</sub>; }
else
   { statements<sub>2</sub>; }
</pre><p>
Assume that <large><code>x</code></large> and <large><code>y</code></large> are labels defined in <large><code>.data</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Iteration Statements</span></td><td align='right'><small>17/58</small></td></tr></table>
<p>
Iteration (e.g. <large><code>while</code></large>)
<p><pre>
                      <font color='#009900'>top_while:</font>
while (Cond) {           t0 = evaluate Cond
   Statements;           <b>beqz</b> $t0,<font color='#009900'>end_while</font>
}                        execute Statements
                         <b>j</b>    <font color='#009900'>top_while</font>
                      <font color='#009900'>end_while:</font>
</pre><p>
Treat <large><code>for</code></large> as a special case of <large><code>while</code></large>
<p><pre>
                                i = 0
for (i = 0; i < N; i++) {       while (i < N) {
    Statements;                    Statements;
}                                  i++;
                                }
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 4: Mapping <tt>while</tt></span></td><td align='right'><small>18/58</small></td></tr></table>
<p>
Implement the following in MIPS assembler
<p><pre>
sum = 0; i = 1;
while (i <= 20) {
   sum = sum + i;
   i++;
}
</pre><p>
Assume that <large><code>i</code></large> and <large><code>sum</code></large> are mapped to registers
<p>
And, of course, the above is equivalent to:
<p><pre>
sum = 0;
for (i = 1; i <= 20; i++)
   sum += i;
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Iteration Statements</span></td><td align='right'><small>19/58</small></td></tr></table>
<p>
Example of iteration over an array:
<p><pre><small>
int sum, i;               sum: .word 4       <span class="comment"># use reg for i</span>
int a[5] = {1,3,5,7,9};   a:   .word 1,3,5,7,9
...                            ...
sum = 0;                       li   $t0, 0   <span class="comment"># i = 0</span>
                               li   $t1, 0   <span class="comment"># sum = 0</span>
                               li   $t2, 4   <span class="comment"># max index</span>
for (i = 0; i < N; i++)   for: bgt  $t0, $t2, end_for
                               move $t3, $t0
                               mul  $t3, $t3, 4
   sum += a[i];                add  $t1, $t1, a($t3)
printf("%d",sum);              addi $t0, $t0, 1   <span class="comment"># i++</span>
                               j    for
                      end_for: sw   $t1, sum
                               move $a0, $t1 
                               li   $v0, 1
                               syscall       <span class="comment"># printf</span>
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Functions</span></td><td align='right'><small>20/58</small></td></tr></table>
<p>
When we call a function:
<ul>
<li> the arguments are evaluated and set up for function
<li> control is transferred to the code for the function
<li> local variables are created
<li> the function code is executed in this environment
<li> the return value is set up
<li> control transfers back to where the function was called from
<li> the caller receives the return value
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>21/58</small></td></tr></table>
<p>
Data associated with function calls is placed on the MIPS stack.
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-memory-small.png]" src="Pics/processor/mips-memory-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>22/58</small></td></tr></table>
<p>
Each function allocates a small section of the stack (a <em>frame</em>)
<ul>
<li> used for: saved registers, local variables, parameters to callees
<li> created in the function <i>prologue</i> &nbsp; <small>(pushed)</small>
<li> removed in the function <i>epilogue</i> &nbsp; <small>(popped)</small>
</ul>
<br>
Why we use a stack:
<ul>
<li> function <large><code>f()</code></large> calls <large><code>g()</code></large> which calls <large><code>h()</code></large>
<li> <large><code>h()</code></large> runs, then finishes and returns to <large><code>g()</code></large>
<li> <large><code>g()</code></large> continues, then finishes and returns to <large><code>f()</code></large>
</ul>
i.e. last-called, exits-first (last-in, first-out) behaviour
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>23/58</small></td></tr></table>
<p>
How stack changes as functions are called and return:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-calls-small.png]" src="Pics/processor/mips-fn-calls-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>24/58</small></td></tr></table>
<p>
Register usage conventions when <large><code>f()</code></large> calls <large><code>g()</code></large>:
<ul>
<li> caller saved registers (saved by <large><code>f()</code></large>)
<ul>
<li> <large><code>f()</code></large> tells <large><code>g()</code></large> "If there is anything I want to preserve in these registers, I have already saved it before calling you"
<li> <large><code>g()</code></large> tells <large><code>f()</code></large> "Don't assume that these registers will be unchanged when I return to you"
<li> e.g. &nbsp;<large><code>$t0</code></large> .. <large><code>$t9</code></large>, &nbsp; <large><code>$a0</code></large> .. <large><code>$a3</code></large>, &nbsp; <large><code>$ra</code></large>
</ul>
<li> callee saved registers (saved by <large><code>g()</code></large>)
<ul>
<li> <large><code>f()</code></large> tells <large><code>g()</code></large> "I assume the values of these registers will be unchanged when you return"
<li> <large><code>g()</code></large> tells <large><code>f()</code></large> "If I need to use these registers, I will save them first and restore them before returning"
<li> e.g. &nbsp;<large><code>$s0</code></large> .. <large><code>$s7</code></large>, &nbsp; <large><code>$sp</code></large>, &nbsp; <large><code>$fp</code></large>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Aside: Branch Delay Slots</span></td><td align='right'><small>25/58</small></td></tr></table>
<p>
Most architectures are "pipelined" to improve efficiency.
<ul>
<li> next instruction(s) can start before previous one(s) finish
<li> MIPS has a two-stage pipeline: fetch, and execute
</ul>

What if a branching instruction (e.g. <large><code>jal</code></large>) is executed?
<ul>
<li> next fetch happens before branch executes &rArr; next instruction is loaded.
<li> so, either 'stall' the pipeline until it completes (slow!)
<li> ... or run the next instruction anyway, in a "branch-delay" slot
</ul>

On classical MIPS, the next instruction is executed <b>before</b> the branch completes.

<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Aside: Branch Delay Slots</span></td><td align='right'><small>26/58</small></td></tr></table>
<p>
To avoid potential problems, use <large><font color="#008800"><b><code>nop</code></b></font></large> immediately after branch
<p>
A problem scenario, and its solution <small>(branch delay slot)</small>:
<p><pre>
<comment># Implementation of <font color='#000099'>print(compute(42))</font></comment>
li   $a0, 42           li   $a0, 42
jal  compute           jal  compute
move $a0, $v0          nop
jal  print             move $a0,$v0
                       jal  print
</pre><p>
Since SPIM is not pipelined (by default), the <large><code>nop</code></large> is not required
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Aside: Why do we need both $fp and $sp?</span></td><td align='right'><small>27/58</small></td></tr></table>
<p>
During execution of a function
<ul>
<li> <large><code>$sp</code></large> can change &nbsp; <small>(e.g. pushing params, adding local vars)</small>
<li> may need to reference local vars on the stack
<li> useful if they can be defined by an offset relative to fixed point
<li> <large><code>$fp</code></large> provides a fixed point during function code execution
</ul>
<p><pre><small>
int f(int x) {
   int y = 0;                   <comment>// y created in prologue</comment>
   for (int i = 0; i < x; i++)  <comment>// i created in for-loop</comment>
      y += i;                   <comment>//     which changes $sp</comment>
   return y;
}
</small></pre><p>
<br>
<small>
It is possible to only use <large><code>$sp</code></large>, which frees up <large><code>$fp</code></large> to become <large><code>$s8</code></large>.<br>
But at the cost of lots of extra work for us in keeping track of stack layout.
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Calls</span></td><td align='right'><small>28/58</small></td></tr></table>
<p>
Simple view of function calls:
<ul>
<li> load argument values into <large><code>$a0</code></large>, <large><code>$a1</code></large>, ...
<li> invoke <large><code>jal</code></large>: loads PC into <large><code>$ra</code></large>, jumps to function
<li> function puts return value in &nbsp;<large><code>$v0</code></large>
<li> returns to caller using &nbsp;<large><code>jr $ra</code></large>
</ul>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/fn-call-small.png]" src="Pics/processor/fn-call-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Calling Protocol</span></td><td align='right'><small>29/58</small></td></tr></table>
<p>
Before one function calls another, it needs to
<ul>
<li> place <small>(32-bit)</small> arguments in the <large><code>$a0</code></large>..<large><code>$a3</code></large>
<li> if more than 4 args, or args larger than 32-bits ...
<ul>
<li> push value of all such args onto stack
</ul>
<li> save any non-<large><code>$s?</code></large> registers that need to be preserved
<ul>
<li> push value of all such registers onto stack
</ul>
<li> <large><code>jal</code></large> address of function (usually given by a label)
</ul>
Pushing value of e.g. <large><code>$t0</code></large> onto stack means:
<p><pre>
addi $sp, $sp, -4      OR      sw   $t0, -4($sp)
sw   $t0, ($sp)                addi $sp, $sp, -4
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>30/58</small></td></tr></table>
<p>
Example: simple function call
<p><pre>
int main()
{
   <comment>// x is $s0, y is $s1, z is $s2</comment>
   int x = 5; int y = 7; int z;
   ...
   z = sum(x,y,30);
   ...
}

int sum(int a, int b, int c)
{
   return a+b+c;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>31/58</small></td></tr></table>
<p>
Simple function call:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-args0-small.png]" src="Pics/processor/mips-fn-args0-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>32/58</small></td></tr></table>
<p>
Execution of <large><code>sum()</code></large> function:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-body0-small.png]" src="Pics/processor/mips-fn-body0-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 5: Simple Function call</span></td><td align='right'><small>33/58</small></td></tr></table>
<p>
Write MIPS code to implement the <font color='#009900'>function call</font> and the <font color='#996600'>function body</font> in ...
<p><pre>
char a[100];

int main(void)
{
   fgets(a, 99, stdin);
   printf("%d\n", <font color='#009900'>length(a,99)</font>);
   return 0;
}
<font color='#996600'>int length(char *s, int n)
{
   int nchars = 0;
   char *end = &s[n];
   while (s < end && *s != '\0')
      { s++; nchars++; }
   return nchars;
}</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Structure of Functions</span></td><td align='right'><small>34/58</small></td></tr></table>
<p>
Functions in MIPS have the following general structure:
<p><pre><small>
# start of function
<font color='#009900'>FuncName:</font>
   # <b>function prologue</b>
   #   set up stack frame ($fp, $sp)
   #   save relevant registers (incl. $ra)
   ...
   # <b>function body</b>
   #   perform computation using $a0, etc.
   #   leaving result in <font color='#009900'>$v0</font>
   ...
   # <b>function epilogue</b>
   #   restore saved registers (esp. $ra)
   #   clean up stack frame ($fp, $sp)
   <font color='#009900'>jr  $ra</font>
</small></pre><p>
Aim of prologue: create environment for function to execute in.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structure of Functions</span></td><td align='right'><small>35/58</small></td></tr></table>
<p>
Contents of a typical stack frame:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-stack-frame-small.png]" src="Pics/processor/mips-stack-frame-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Prologue</span></td><td align='right'><small>36/58</small></td></tr></table>
<p>
Before a function starts working, it needs to ...
<ul>
<li> create a stack frame for itself &nbsp;(change <large><code>$fp</code></large> and <large><code>$sp</code></large>)
<li> save the return address (<large><code>$ra</code></large>) in the stack frame
<li> save any <large><code>$s?</code></large> registers that it plans to change
</ul>
We can determine the initial size of the stack frame via
<ul>
<li> 4 bytes for saved <large><code>$fp</code></large> + 4 bytes for saved <large><code>$ra</code></large>
<li> + 4 bytes for each saved <large><code>$s?</code></large>
</ul>
Changing <large><code>$fp</code></large> and <large><code>$sp</code></large> ...
<ul>
<li> new <large><code>$fp</code></large> = old <large><code>$sp</code></large> - 4
<li> new <large><code>$sp</code></large> = old <large><code>$sp</code></large> - size of frame <small>(in bytes)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Prologue</span></td><td align='right'><small>37/58</small></td></tr></table>
<p>
Example of function <large><code>fx()</code></large>, which uses <large><code>$s0</code></large>, <large><code>$s1</code></large>, <large><code>$s2</code></large>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-prologue-small.png]" src="Pics/processor/mips-fn-prologue-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Prologue</span></td><td align='right'><small>38/58</small></td></tr></table>
<p>
Alternatively ... <small>(more explicit <large><code>push</code></large>)</small>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-prologue2-small.png]" src="Pics/processor/mips-fn-prologue2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Prologue</span></td><td align='right'><small>39/58</small></td></tr></table>
<p>
Alternatively ... <small>(relative to new <large><code>$fp</code></large>)</small>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-prologue3-small.png]" src="Pics/processor/mips-fn-prologue3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Epilogue</span></td><td align='right'><small>40/58</small></td></tr></table>
<p>
Before a function returns, it needs to ...
<ul>
<li> place the return value in <large><code>$v0</code></large> &nbsp;<small>(and maybe <large><code>$v1</code></large>)</small>
<li> pop any pushed arguments off the stack
<li> restore the values of any saved <large><code>$s?</code></large> registers
<li> restore the saved value of <large><code>$ra</code></large> &nbsp; <small>(return address)</small>
<li> remove its stack frame &nbsp;(change <large><code>$fp</code></large> and <large><code>$sp</code></large>)
<li> return to the calling function &nbsp; (<large><code>jr $ra</code></large>)
</ul>
Locations of saved values computed relative to <large><code>$fp</code></large>
<p>
Changing <large><code>$fp</code></large> and <large><code>$sp</code></large> ...
<ul>
<li> new <large><code>$sp</code></large> = old <large><code>$fp</code></large> + 4,
	&nbsp;&nbsp;&nbsp; new <large><code>$fp</code></large> = <large><code>memory[</code></large>old <large><code>$fp]</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Epilogue</span></td><td align='right'><small>41/58</small></td></tr></table>
<p>
Example of function <large><code>fx()</code></large>, which uses <large><code>$s0</code></large>, <large><code>$s1</code></large>, <large><code>$s2</code></large>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-epilogue-small.png]" src="Pics/processor/mips-fn-epilogue-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 6: Function to compute 1+2+3+...+n</span></td><td align='right'><small>42/58</small></td></tr></table>
<p>
Implement the function <large><code>sumTo()</code></large>
<p><pre>
int main()
{
   int max;
   print("Enter +ve integer: ");
   scanf("%d", &max);
   printf("Sum 1..%d = %d\n", max, sumTo(max));
   return 0;
}

int sumTo(int n)
{
   int sum = 0;
   for (int i = 1; i <= n; i++) sum += i;
   return sum;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Data Structures and MIPS</span></td><td align='right'><small>43/58</small></td></tr></table>
<p>
C data structures and their MIPS representations:
<ul>
<li> <large><code>char</code></large> ... as byte in memory, or low-order byte in register
<li> <large><code>int</code></large> ... as one word in memory, or whole register
<li> <large><code>double</code></large> ... as two words in memory, or <large><code>$f?</code></large> register
<li> arrays ... sequence of memory bytes/words, accessed by index
<li> structs ... chunk of memory, accessed by fields <small>(in C)</small> or offsets <small>(in MIPS)</small>
<li> linked structures ... struct containing address of another struct
</ul>
A <large><code>char</code></large>, <large><code>int</code></large> or <large><code>double</code></large>
<ul>
<li> could be implemented in register if used in small scope
<li> could be implemented on stack if local to function
<li> could be implemented in <large><code>.data</code></large> if need longer persistence/lifetime
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Static vs Dynamic Allocation</span></td><td align='right'><small>44/58</small></td></tr></table>
<p>
Static allocation:
<ul>
<li> uninitialised memory allocated at compile/assemble-time, e.g.
<p><pre>
int  val;              val: .space 4
char str[20];          str: .space 20
int  vec[20];          vec: .space 80
</pre><p>
<li> initialised memory allocated at compile/assemble-time, e.g.
<p><pre>
int val = 5;                 val: .word 5
int arr[4] = {9,8,7,6};      arr: .word 9, 8, 7, 6
char *msg = "Hello\n";       msg: .asciiz "Hello\n"
</pre><p>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>45/58</small></td></tr></table>
<p>
Dynamic allocation:
<ul>
<li> variables local to a function
</ul>
Prefer to put local vars in registers, but if cannot ...
<ul>
<li> use space allocated on stack during function prologue
<li> referenced during function relative to <large><code>$fp</code></large>
<li> space reclaimed from stack in function epilogue
</ul>
Example:
<p><pre>
int fx(int a[])
{
   <font color='#009900'>int i, j, max;</font>
   i = 1; j = 2; max = i+j;
   ...
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>46/58</small></td></tr></table>
<p>
Example of local variables on the stack:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/local-vars-small.png]" src="Pics/processor/local-vars-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>1-d Arrays in MIPS</span></td><td align='right'><small>47/58</small></td></tr></table>
<p>
Can be named/initialised as noted above:
<p><pre>
vec:  .space 40
<comment># could be either <b>int</b> vec[10] or <b>char</b> vec[40]</comment>

nums: .word 1, 3, 5, 7, 9
<comment># int nums[6] = {1,3,5,7,9}</comment>
</pre><p>
Can access elements via index or cursor (pointer)
<ul>
<li> either approach needs to account for size of elements
</ul>
Arrays passed to functions via pointer to first element
<ul>
<li> must also pass array size, since not available elsewhere
</ul>
<small>
See <large><code>sumOf()</code></large> exercise for an example of passing an array to a function
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 1-d Arrays in MIPS</span></td><td align='right'><small>48/58</small></td></tr></table>
<p>
Scanning across an array of <large><code>N</code></large> elements using index
<p><pre>
<font color='#000099'># int vec[10] = {...};
# int i;
# for (i = 0; i < 10; i++)
#    printf("%d\n", vec[i]);</font>

   li   $s0, 0               <comment># i = 0</comment>
   li   $s1, 10              <comment># no of elements</comment>
   li   $s2, 4               <comment># sizeof each element</comment>
loop: 
   bge  $s0, $s1, end_loop   <comment># if (i >= 10) break</comment>
   mul  $t0, $s0, $s2        <comment># index -> byte offset</comment>
   lw   $a0, vec($t0)        <comment># a0 = vec[i]</comment>
   jal  print                <comment># print a0</comment>
   addi $s0, $s0, 1          <comment># i++</comment>
   j    loop
end_loop:
</pre><p>
<small>Assumes the existence of a <large><code>print()</code></large> function to do <large><code>printf("%d\n",x)</code></large></small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 1-d Arrays in MIPS</span></td><td align='right'><small>49/58</small></td></tr></table>
<p>
Scanning across an array of <large><code>N</code></large> elements using cursor
<p><pre>
<font color='#000099'># int vec[10] = {...};
# int *cur, *end = &vec[10];
# for (cur = vec; cur < end; cur++)
#    printf("%d\n", *cur);</font>

   la   $s0, vec             <comment># cur = &vec[0]</comment>
   la   $s1, vec+40          <comment># end = &vec[10]</comment>
loop:
   bge  $s0, $s1, end_loop   <comment># if (cur >= end) break</comment>
   lw   $a0, ($s0)           <comment># a0 = *cur</comment>
   jal  print                <comment># print a0</comment>
   addi $s0, $s0, 4          <comment># cur++</comment>
   j    loop
end_loop:
</pre><p>
<small>Assumes the existence of a <large><code>print()</code></large> function to do <large><code>printf("%d\n",x)</code></large></small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 1-d Arrays in MIPS</span></td><td align='right'><small>50/58</small></td></tr></table>
<p>
Arrays that are local to functions are allocated space on the stack
<p><pre><small>
fun:                         int fun(int x) 
   <comment># prologue</comment>                {
   addi $sp, $sp, -4
   sw   $fp, ($sp)
   move $fp, $sp
   addi $sp, $sp, -4
   sw   $ra, ($sp)              // push a[] onto stack
   addi $sp, $sp, -40           int a[10];
   move $s0, $sp                int *s0 = a;
   <comment># function body</comment>
   ... compute ...              // compute using s0
   <comment># epilogue</comment>                   // to access a[]
   addi $sp, $sp, 40            // pop a[] off stack
   lw   $ra, ($sp)
   addi $sp, $sp, 4
   lw   $fp, ($sp)
   addi $sp, $sp, 4
   jr   $ra                  }
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 7: Function to sum values in array</span></td><td align='right'><small>51/58</small></td></tr></table>
<p>
Implement a MIPS version of the following:
<p><pre>
int array[10] = {5,4,7,6,8,9,1,2,3,0};

int main(void)
{
   printf("%d\n", sumOf(array,10));
   return 0;
}

int sumOf(int a[], int n)
{
   int i;  int sum = 0;
   for (i = 0; i < n; i++) sum += a[i];
   return sum;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 8: Recursive function to sum values in array</span></td><td align='right'><small>52/58</small></td></tr></table>
<p>
Implement a MIPS version of the following:
<p><pre>
int array[10] = {5,4,7,6,8,9,1,2,3,0};

int main(void)
{
   printf("%d\n", sumOf(array,0,9));
   return 0;
}

int sumOf(int a[], int lo, int hi)
{
   if (lo > hi)
      return 0;
   else
      return a[lo] + sumOf(a,lo+1,hi);
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>2-d Arrays in MIPS</span></td><td align='right'><small>53/58</small></td></tr></table>
<p>
2-d arrays could be represented two ways:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/2d-array-small.png]" src="Pics/processor/2d-array-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>54/58</small></td></tr></table>
<p>
Representations of &nbsp;<large><code>int matrix[4][4]</code></large> ...
<p><pre>
<comment># for strategy (a)</comment>
matrix: .space 64
<comment># for strategy (b)</comment>
row0:   .space 16
row1:   .space 16
row2:   .space 16
row3:   .space 16
matrix: .word row0, row1, row2, row3
</pre><p>
Now consider summing all elements
<p><pre>
int i, j, sum = 0;
for (i = 0; i < 4; i++)
   for (j = 0; j < 4; j++)
      sum += matrix[i][j];
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>55/58</small></td></tr></table>
<p>
Accessing elements:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/2d-array-access-small.png]" src="Pics/processor/2d-array-access-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>56/58</small></td></tr></table>
<p>
Computing sum of all elements in &nbsp;<large><code>int matrix[6][5]</code></large> in C
<p><pre>
int row, col, sum = 0;

<comment>// row-by-row</comment>
for (row = 0; row < 6; row++) {
   <comment>// col-by-col within row</comment>
   for (col = 0; col < 5; row++) {
      sum += matrix[row][col];
   }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>57/58</small></td></tr></table>
<p>
Computing sum of all elements for strategy (a) &nbsp;<large><code>int matrix[6][5]</code></large>
<p><pre><small>
   li  $s0, 0             <comment># sum = 0</comment>
   li  $s1, 6             <comment># s1 = #rows</comment>
   li  $s2, 0             <comment># row = 0</comment>
   li  $s3, 5             <comment># s3 = #cols</comment>
   li  $s4, 0             <comment># col = 0 // redundant</comment>
   li  $s5, 4             <comment># intsize = sizeof(int)</comment>
   mul $s6, $s3, $s5      <comment># rowsize = #cols*intsize</comment>
loop1:
   bge  $s2, $s1, end1    <comment># if (row >= 6) break</comment>
   li   $s4, 0            <comment># col = 0</comment>
loop2:
   bge  $s4, $s3, end2    <comment># if (col >= 5) break</comment>
   mul  $t0, $s2, $s6     <comment># t0 = row*rowsize</comment>
   mul  $t1, $s4, $s5     <comment># t1 = col*intsize</comment>
   add  $t0, $t0, $t1     <comment># offset = t0+t1</comment>
   lw   $t0, matrix($t0)  <comment># t0 = *(matrix+offset)</comment>
   add  $s0, $s0, $t0     <comment># sum += t0</comment>
   addi $s4, $s4, 1       <comment># col++</comment>
   j    loop2
end2:
   addi $s2, $s2, 1       <comment># row++</comment>
   j    loop1
end1:
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>58/58</small></td></tr></table>
<p>
Computing sum of all elements for strategy (b) &nbsp;<large><code>int matrix[4][4]</code></large>
<p><pre><small>
   li  $s0, 0             <comment># sum = 0</comment>
   li  $s1, 4             <comment># s1 = 4 (sizeof(int))</comment>
   li  $s2, 0             <comment># row = 0</comment>
loop1:
   beq  $s2, $s1, end1    <comment># if (row >= 4) break</comment>
   li   $s3, 0            <comment># col = 0</comment>
   mul  $t0, $s2, $s1     <comment># off = 4*i</comment>
   lw   $s4, matrix($t0)  <comment># rowp = &matrix[i][0]</comment>
loop2:
   beq  $s3, $s1, end2    <comment># if (col >= 4) break</comment>
   mul  $t0, $s3, $s1     <comment># off = 4*col</comment>
   add  $t0, $t0, $s4     <comment># int *p = &rowp[col]</comment>
   lw   $t0, ($t0)        <comment># t0 = *p</comment>
   add  $s0, $s0, $t0     <comment># sum += t0</comment>
   addi $s3, $s3, 1       <comment># col++</comment>
   j    loop2
end2:
   addi $s2, $s2, 1       <comment># row++</comment>
   j    loop1
end1:
</small></pre><p>
<p><hr><p>
<small><small>Produced: 8 Aug 2019</small></small>
</body>
</html>

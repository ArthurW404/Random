<html>
<head>
<title>Week 05</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Week 05</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Structs in MIPS</span></td><td align='right'><small>1/38</small></td></tr></table>
<p>
C <large><code>struct</code></large>s hold a collection of values accessed by name
<p><div class='center'>
<img alt="[Diagram:Pics/processor/struct-small.png]" src="Pics/processor/struct-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>2/38</small></td></tr></table>
<p>
C <large><code>struct</code></large> definitions effectively define a new type.
<p><pre>
<comment>// new type called "struct _student"</comment>
struct _student {...};
<comment>// new type called Student</comment>
typedef struct _student Student;
</pre><p>
Instances of structures can be created by allocating space:
<p><pre>
                  <comment>// sizeof(Student) == 56</comment>
stu1:             Student stu1;
   .space 56
stu2:             Student stu2;
   .space 56
stu:
   .space 4       Student *stu;
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>3/38</small></td></tr></table>
<p>
Accessing structure components is by offset, not name
<p><pre>
stu1: .space 56       <font color='#000099'># Student stu1;</font>
stu2: .space 56       <font color='#000099'># Student stu2;</font>
# stu is $s1          <font color='#000099'># Student *stu;</font>

li  $t0  5012345
sw  $t0, <font color='#009900'>stu1+0</font>       <font color='#000099'># stu1.id = 5012345;</font>
li  $t0, 3778
sw  $t0, <font color='#009900'>stu1+44</font>      <font color='#000099'># stu1.program = 3778;</font>

la  $s1, stu2         <font color='#000099'># stu = &stu2;</font>
li  $t0, 3707
sw  $t0, <font color='#009900'>44($s1)</font>      <font color='#000099'># stu->program = 3707;</font>
li  $t0, 5034567
sw  $t0, <font color='#009900'>0($s1)</font>       <font color='#000099'># stu->id = 5034567;</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>4/38</small></td></tr></table>
<p>
Structs that are local to functions are allocated space on the stack
<p><pre><small>
fun:                         int fun(int x) 
   <comment># prologue</comment>                {
   addi $sp, $sp, -4
   sw   $fp, ($sp)
   move $fp, $sp
   addi $sp, $sp, -4
   sw   $ra, ($sp)              // push onto stack
   <font color='#009900'>addi $sp, $sp, -56</font>           Student st;
   <font color='#009900'>move $t0, $sp</font>                Student *t0 = &st;
   <comment># function body</comment>
   ... compute ...              // compute using t0
   <comment># epilogue</comment>                   // to access struct
   <font color='#009900'>addi $sp, $sp, 56</font>            // pop st off stack
   lw   $ra, ($sp)
   addi $sp, $sp, 4
   lw   $fp, ($sp)
   addi $sp, $sp, 4
   jr   $ra                  }
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>5/38</small></td></tr></table>
<p>
C can pass whole structures to functions, e.g.
<p><pre><small>
<font color='#000099'># Student stu; ...
# // set values in stu struct
# showStudent(<font color='#009900'>stu</font>);</font>

   .data
stu: .space 56
   .text
   ...
   la   $t0, stu
   addi $sp, $sp, -56    <comment># push Student object onto stack</comment>
   lw   $t1, 0($t0)      <comment># allocate space and copy all</comment>
   sw   $t1, 0($sp)      <comment># values in Student object</comment>
   lw   $t1, 4($t0)      <comment># onto stack</comment>
   sw   $t1, 4($sp)
   ...
   lw   $t1, 52($t0)     <comment># and once whole object copied</comment>
   sw   $t1, 52($sp)
   jal  showStudent      <comment># invoke showStudent()</comment>
   ...
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>6/38</small></td></tr></table>
<p>
Accessing <large><code>struct</code></large> within function ...
<p><div class='center'>
<img alt="[Diagram:Pics/processor/pass-struct-by-value-small.png]" src="Pics/processor/pass-struct-by-value-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>7/38</small></td></tr></table>
<p>
Can also pass a pointer to a <large><code>struct</code></large>
<p><pre><small>
<font color='#000099'># Student stu;
# // set values in stu struct
# changeWAM(<font color='#009900'>&stu</font>, float newWAM);</font>

   .data
stu: .space 56
wam: .space 4
   .text
   ...
   la   $a0, stu
   lw   $a1, wam
   jal  changeWAM
   ...
</small></pre><p>
Clearly a more efficient way to pass a large <large><code>struct</code></large>
<p>
Also, required if the function needs to update the original <large><code>struct</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Passing <large><code>struct</code></large>s by reference</span></td><td align='right'><small>8/38</small></td></tr></table>
<p>
Write a MIPS function that implements:
<p><pre>
typedef struct _Person {
   int  id_no;
   char family[15];
   char given[15];
} Person;

void showPerson(Person *p)
{
   printf("%d ", p->id_no);
   printf("%s, %s\n", p->family, p->given);
}
</pre><p>
which might produce output like
<p><pre>
5000035 Shepherd, John
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Compiling C to MIPS</span></td><td align='right'><small>9/38</small></td></tr></table>
<p>
What does the compiler need to do to convert C to MIPS?
<ul>
<li> pre-process <large><code>#include</code></large> and <large><code>#define</code></large>
<li> <em>parse</em> code to check syntactically valid
<li> manage a list of <em>symbols</em> used in program
<li> decide how to represent data structures 
<li> allocate local variables to registers or stack
<li> map control structures to MIPS instructions
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Symbol (Name) Management</span></td><td align='right'><small>10/38</small></td></tr></table>
<p>
Compiler keeps track of names
<ul>
<li> scope, lifetime, locally/externally defined
<li> disambiguates e.g. &nbsp;<large><code>x</code></large> in <large><code>main()</code></large> &nbsp;vs &nbsp;<large><code>x</code></large> in <large><code>fun()</code></large>
<li> resolves symbols to specific locations (data/stack/registers)
<li> external symbols may remain unresolved until linking
<li> however, need to have a type for each external symbol
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Local Variables</span></td><td align='right'><small>11/38</small></td></tr></table>
<p>
Two choices for local variables
<ul>
<li> on the stack ... <font color='#009900'>+</font>persist for whole function, <big><font color='#CC0000'>-</font></big><large><code>lw</code></large>/<large><code>sw</code></large> needed
<li> in a register ... <font color='#009900'>+</font>efficient, <big><font color='#CC0000'>-</font></big>not many registers
<ul>
<li> if need to persist across function calls, use <large><code>$s?</code></large> register
<li> if used in very localised scope, can use <large><code>$t?</code></large> register
</ul>
</ul>
Example:
<p><pre>
int sum(List L)
{
   if (L == NULL) return 0;
   int <font color='#009900'>first</font> = L->value;     <comment>// must be in $s?</comment>
   int <font color='#CC0000'>rest</font> = <font color='#000099'>sum</font>(L->next);  <comment>// can be in $t?</comment>
   return <font color='#009900'>first</font> + <font color='#CC0000'>rest</font>;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Expression Evaluation</span></td><td align='right'><small>12/38</small></td></tr></table>
<p>
Uses temporary (<large><code>$t?</code></large>) registers
<ul>
<li> even complex expressions don't generally need &gt; 3-4 registers
</ul>
Example:
<p><pre>
   <font color='#0000CC'>x = ((y+3) * (z-2) * x) / 4;</font>

   lw   $t0, y
   addi $t0, $t0, 3    <comment># t0 = y + 3</comment>
   lw   $t1, z
   addi $t1, $t1, -2   <comment># t1 = z - 2</comment>
   mul  $t0, $t0, $t1  <comment># t0 = t0 * t1</comment>
   lw   $t1, x
   mul  $t0, $t0, $t1  <comment># t0 = t0 * x</comment>
   li   $t1, 4
   div  $t0, $t0, $t1  <comment># t0 = t0 / 4</comment>
</pre><p>
Reminder: boolean expressions handled by short-circuit evaluation.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Mapping Control Structures</span></td><td align='right'><small>13/38</small></td></tr></table>
<p>
Use templates, e.g.
<p><pre>
<font color='#0000CC'>while (<i>Cond</i>) { <i>Stat1</i>; <i>Stat2</i>; ... }</font>

loop:
   <comment>MIPS code to check <i>Cond</i>; result in $t0</comment>
   beqz $t0, end_loop
   <comment>MIPS code for <i>Stat1</i></comment>
   <comment>MIPS code for <i>Stat2</i></comment>
   <comment>MIPS code for <i>...</i></comment>
   j    loop
end_loop:
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Mapping Control Structures</span></td><td align='right'><small>14/38</small></td></tr></table>
<p>
Template for <large><code>if...else if... else</code></large>
<p><pre>
<font color='#0000CC'>if (<i>Cond1</i>) <i>Stat1</i> else if (<i>Cond2</i>) <i>Stat2</i> else <i>Stat3</i></font>

if:
   <comment>MIPS code to check <i>Cond1</i>; result in $t0</comment>
   beqz $t0, else1
   <comment>MIPS code for <i>Stat1</i></comment>
   j    end_if
else1:
   <comment>MIPS code to check <i>Cond2</i>; result in $t0</comment>
   beqz $t0, else2
   <comment>MIPS code for <i>Stat2</i></comment>
   j    end_if
else2:
   <comment>MIPS code for <i>Stat3</i></comment>
end_if:
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'> Argc and Argv</span></td><td align='right'><small>15/38</small></td></tr></table>
<p>
The real MIPS machine has no idea about <large><code>argc</code></large> and <large><code>argv</code></large>
<p>
SPIM runs under Linux, and needs to interact with environment
<p>
So, the initialisation code (that invokes <large><code>main</code></large>) sets up <large><code>argc</code></large>/<large><code>argv</code></large>:
<p><pre>
    lw    $a0 0($sp)   # argc 
    addiu $a1 $sp 4    # argv 
    ...
    jal   main 
    nop 
    li    $v0 10 
    syscall            # syscall 10 (exit) 
</pre><p>
<p><br>
<small>
Note: we are ignoring <large><code>envp</code></large> (environment pointer)
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  Argc and Argv</span></td><td align='right'><small>16/38</small></td></tr></table>
<p>
What the <large><code>main()</code></large> function receives:
<p><div class='center'>
<img alt="[Diagram:Pics/mips/argc-argv-small.png]" src="Pics/mips/argc-argv-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  Argc and Argv</span></td><td align='right'><small>17/38</small></td></tr></table>
<p>
Code to print the program's name (<large><code>argv[0]</code></large>):
<p><pre>
   # assume argc is $s0, argv is $s1
   addi   $t0, $s1, 0    <comment># &argv[0]</comment>
   lw     $a0, ($t0)     <comment># argv[]</comment>
   li     $v0, 4
   syscall
</pre><p>
Code to print the first cmd-line arg (<large><code>argv[1]</code></large>)
<p><pre>
   # assume argc is $s0, argv is $s1
   addi   $t0, $s1, 4    <comment># &argv+4</comment>
   lw     $a0, ($t0)     <comment># argv[]</comment>
   li     $v0, 4
   syscall
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 2: Echo in SPIM</span></td><td align='right'><small>18/38</small></td></tr></table>
<p>
Give an implementation of the <large><code>echo</code></large> command in SPIM
<p><pre>
int main(int argc, char *argv[])
{
   for (int i = 1; i < argc; i++)
      printf("%s ", argv[i]);
   printf("\n");
}
</pre><p>
OR
<p><pre>
int main(int argc, char **argv)
{
   for (int i = 1; i < argc; i++)
      printf("%s ", *argv++);
   printf("\n");
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Computer Systems Architecture</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Computer Systems Architecture</span></td><td align='right'><small>20/38</small></td></tr></table>
<p>
Computer system: hardware core surrounded by layers of software
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/layers-small.png]" src="Pics/opsys/layers-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Operating Systems</span></td><td align='right'><small>21/38</small></td></tr></table>
<p>
Modern computer: devices connected via a system bus ...
<p><br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware-small.png]" src="Pics/opsys/hardware-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Operating Systems</span></td><td align='right'><small>22/38</small></td></tr></table>
<p>
Operating systems (OSs)
<ul>
<li> provide an abstraction layer on top of hardware
<li> i.e. same view available regardless of underlying hardware
</ul>
Some characteristics of OSs
<ul>
<li> have <em>privileged</em> access to the raw machine
<li> <em>manage</em> use of machine resources (CPU, disk, memory, etc.)
<li> provide <em>uniform interface</em> to access machine-level operations
<li> arrange for <em>controlled execution</em> of user programs
<li> provide <em>multi-tasking</em> and (pseudo) parallelism
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Operating Systems</span></td><td align='right'><small>23/38</small></td></tr></table>
<p>
Some different flavours of OSs ...
<ul>
<li> <em>batch</em> &nbsp;<small>(e.g. Eniac, early IBM OSs)</small>
<ul>
<li> computational jobs run one-at-a-time via a queue
</ul>
<li> <em>multi-user</em> &nbsp;<small>(e.g. Multics, Unix/Linux, OSX, Windows)</small>
<ul>
<li> mulitple jobs (appear to) run in parallel
</ul>
<li> <em>embedded</em> &nbsp;<small>(e.g. Android, iOS, ...)</small>
<ul>
<li> small(ish), cut-down OS embedded in a device
</ul>
<li> <em>real-time</em> &nbsp;<small>(e.g. RTLinux, DuinOS, ...)</small>
<ul>
<li> specialised OS with time guarantees on job completion
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Operating Systems</span></td><td align='right'><small>24/38</small></td></tr></table>
<p>
Evolution of Unix ... 1970's
<ul>
<li> complexity of 1960's OSs drove Bell Labs researchers to
<ul>
<li> develop a small OS core, written mostly in HLL
<li> with a set of simple tools and ways of combining them
</ul>
<li> writing OS core in HLL made it portable
<ul>
<li> same OS environment provided on many different machines
</ul>
</ul>
Evolution of Unix/Linux ... 1980's - present
<ul>
<li> Unix and variants ported to wide variety of architectures
<ul>
<li> BSD, SysV, Linux, OS X, Android all based on Unix
</ul>
<li> developments in hardware/software led to more OS services
<ul>
<li> databases, O-O programming, GUI interfaces, games
<li> networking, multi-CPU systems, mobile devices, etc.
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Operating Systems</span></td><td align='right'><small>25/38</small></td></tr></table>
<p>
Abstractions provided by modern OSs
<ul>
<li> users ... who can access (login to) the system
<li> access rights ... what users are allowed to do
<li> file system ... how data is organised on storage devices
<li> input/output ... transferring data to/from devices
<li> processes ... active "computational entities" on the system
<li> communication ... how processes interact
<li> networking ... how the system talks to other systems
</ul>
Core OS functions form the operating system <em>kernel</em>.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Operating Systems</span></td><td align='right'><small>26/38</small></td></tr></table>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/os-core-small.png]" src="Pics/opsys/os-core-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Operating Systems</span></td><td align='right'><small>27/38</small></td></tr></table>
<p>
Critical to OS development: execution modes
<p>
CPUs can typically run in two modes:
<ul>
<li> <em>privileged</em> mode
<ul>
<li> full access to all machine operations and memory regions
</ul>
<li> <em>non-privileged</em> (<em>user</em>) mode
<ul>
<li> a limited set of operations <small>(but still Turing complete)</small>
<li> access to only part of the memory
</ul>
</ul>
System calls allow programs ...
<ul>
<li> to cross the privileged/user boundary
<li> in a controlled manner, via well-defined requests
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>System Calls</span></td><td align='right'><small>28/38</small></td></tr></table>
<p>
SPIM has no OS, but provides a simple set of "system calls"
<ul>
<li> primarily for i/o (read/write) on various types
<li> also memory allocation and process exit
</ul>
An OS like Unix/Linux provides 100's of <em>system calls</em>
<ul>
<li> process management &nbsp; <small>(e.g. <large><code>fork()</code></large>, <large><code>exec()</code></large>, <large><code>_exit()</code></large>, ...)</small>
<li> file management &nbsp; <small>(e.g. <large><code>open()</code></large>, <large><code>read()</code></large>, <large><code>fstat()</code></large>, ...)</small>
<li> device management &nbsp; <small>(e.g. <large><code>ioctl()</code></large>, ...)</small>
<li> information maintenance &nbsp; <small>(e.g. <large><code>settimeofday()</code></large>, <large><code>getuid()</code></large>, ...)</small>
<li> communication &nbsp; <small>(e.g. <large><code>pipe()</code></large>, <large><code>connect()</code></large>, <large><code>send()</code></large>, ...)</small>
</ul>
User programs invoke sys calls through an API (POSIX + Linux)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... System Calls</span></td><td align='right'><small>29/38</small></td></tr></table>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/os-syscalls-small.png]" src="Pics/opsys/os-syscalls-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Libraries</span></td><td align='right'><small>30/38</small></td></tr></table>
<p>
User programs can request services via system calls
<ul>
<li> but system calls provide relatively low-level operations
</ul>
To simplify programming, provide <em>libraries</em>
<ul>
<li> collections of useful functions
<li> referenced from within user programs as C functions
<li> defined by &nbsp;<large><font color="#008800"><b><code>#include &lt;xxx.h&gt;</code></b></font></large>
<li> integrated with user code at "link time"
</ul>
Examples of libraries:
<ul>
<li> <large><code>stdio.h</code></large> ... text-oriented, formatted input/output
<li> <large><code>stdlib.h</code></large> ... wide range of functions, <small>e.g. &nbsp;<large><code>rand()</code></large>, &nbsp;<large><code>malloc()</code></large></small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Libraries</span></td><td align='right'><small>31/38</small></td></tr></table>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/libraries-small.png]" src="Pics/opsys/libraries-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Applications</span></td><td align='right'><small>32/38</small></td></tr></table>
<p>
User-level programs which perform some useful task
<ul>
<li> possibly supplied with system <small>e.g. &nbsp;<large><code>ls</code></large>, &nbsp;<large><code>vim</code></large>, &nbsp;<large><code>gcc</code></large></small>
<li> possibly implemented by users <small>e.g. &nbsp;<large><code>dcc</code></large>, &nbsp;<large><code>check</code></large>, &nbsp;<large><code>Webcms3</code></large></small>
</ul>
Applications live in &nbsp;<large><code>/bin</code></large>, &nbsp;<large><code>/usr/bin</code></large>, etc &nbsp;(via <large><code>PATH</code></large>)
<p>
Applications are generally built using libraries
<ul>
<li> but may also make direct use of system calls
</ul>
Unix was unusual in having a command interpreter (<large><code>bash</code></large>)
<ul>
<li> that runs as a user-level process <small>(not privileged)</small>
<li> but can invoke other user-level processes
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Applications</span></td><td align='right'><small>33/38</small></td></tr></table>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/apps-small.png]" src="Pics/opsys/apps-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>System Calls</span></td><td align='right'><small>34/38</small></td></tr></table>
<p>
System calls are invoked ...
<ul>
<li> directly, through a library of system calls
<ul>
<li> documented in Unix Programmers Manual section 2 <br> (e.g. <large><code>man 2 open</code></large>)
</ul>
<li> indirectly, through functions in the C libraries
<ul>
<li> documented in Unix Programmers Manual section 3 <br> (e.g. <large><code>man 3 fopen</code></large>)
</ul>
</ul>
Example of system call library vs C library
<ul>
<li> file descriptors, <large><code>open()</code></large>, <large><code>close()</code></large>, <large><code>read()</code></large>, <large><code>write()</code></large> <br> <small>(via <large><code>#include &lt;unistd.h&gt;</code></large>)</small>
<li> file pointers (<large><code>FILE*</code></large>), <large><code>fopen()</code></large>, <large><code>fclose</code></large>, <large><code>scanf()</code></large>, <large><code>printf()</code></large> <br> <small>(via <large><code>#include &lt;stdio.h&gt;</code></large>)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Failed System Calls</span></td><td align='right'><small>35/38</small></td></tr></table>
<p>
System calls attempt to perform actions, but may fail
<p>
User programs can detect this in several ways
<ul>
<li> check return value of sys call function &nbsp;<small>(-1 typically flags an error)</small>
<li> check global variable <large><font color="#008800"><b><code>errno</code></b></font></large> &nbsp;<small>(contains specific error)</small>
</ul>
C programs need to check and handle errors themselves
<ul>
<li> unlike other languages, C provides no exception handling
</ul>
Note: successful system calls generally return 0
<ul>
<li> unless the sysetm call has a result value &nbsp;<small>(e.g. #bytes read)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Failed System Calls</span></td><td align='right'><small>36/38</small></td></tr></table>
<p>
Action in response to failed system call is often e.g.
<p><pre>
fprintf(stderr, "Can't do %s", <i>Something</i>);
exit(1);
</pre><p>
<br>
Can give more precise feedback via library functions, e.g.
<ul>
<li> <large><font color="#008800"><b><code>void perror(char *</code></b></font></large><i>Message</i><large><font color="#008800"><b><code>)</code></b></font></large>
<li> if <i>Message</i> not <large><code>NULL</code></large>, write to <large><code>stderr</code></large>
<li> write standard message corresponding to <large><code>errno</code></large>
</ul>
Could then do &nbsp;<large><font color="#008800"><b><code>exit(errno);</code></b></font></large>&nbsp; to send precise error to shell.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Failed System Calls</span></td><td align='right'><small>37/38</small></td></tr></table>
<p>
Linux library function to make it easy to report errors and exit
<ul>
<li> <large><font color="#008800"><b><code>error(</code></b></font></large><i>Status</i>, <i>ErrNum</i>, <i>Format</i>, <i>Expressions</i>, ...<large><font color="#008800"><b><code>)</code></b></font></large>
<li> print error message using prog name, <i>Format</i> and <i>Expressions</i>
<li> if <i>Status</i> is non-zero, invoke <large><code>exit(</code></large><i>Status</i><large><code>)</code></large> after printing message
<li> if <i>ErrNum</i> is non-zero, also print standard system error message
</ul>
Example:
<p><pre>
error(1, errno, "Can't do %s", <i>Something</i>);
<comment>vs</comment>
fprintf(stderr, "Can't do %s", <i>Something</i>);
exit(1);
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 3: Failed System Call</span></td><td align='right'><small>38/38</small></td></tr></table>
<p>
What is displayed after an attempt to open a non-existent file
<p><pre>
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;error.h&gt;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
   int in;
   if (argc < 2)
      error(1, 0, "Usage: %s File", argv[0]);
   in = open(argv[1],O_RDONLY);
   if (in < 0)
      error(errno, errno, "Can't open %s", argv[1]);
   close(in);
   return 0;
}
</pre><p>
<p><hr><p>
<small><small>Produced: 8 Aug 2019</small></small>
</body>
</html>
